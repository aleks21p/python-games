
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W, H, scale;
  function resize(){
    const rect = canvas.getBoundingClientRect();
    W = canvas.width = Math.floor(rect.width);
    H = canvas.height = Math.floor(rect.height);
    scale = W / 900; // base scale
  }
  window.addEventListener('resize', resize);
  resize();

  // Game constants (tuned to spec)
  const LEVELS = 6;
  let currentLevel = 1;
  let running = false;

  // Player (arrow) visual geometry (scaled and rotated)
  // Spec: base 48px, height 64px, isosceles triangle pointing right
  function makeArrowPoly(x, y, angle){
    const baseW = Math.round(48 * scale);
    const height = Math.round(64 * scale);
    const halfH = height / 2;
    
    // Triangle points relative to center (before rotation)
    const points = [
      {x: halfH, y: 0}, // tip (right)
      {x: -halfH, y: -baseW/2}, // top-left
      {x: -halfH, y: baseW/2}  // bottom-left
    ];
    
    // Rotate points
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const rotated = points.map(p => ({
      x: x + p.x * cos - p.y * sin,
      y: y + p.x * sin + p.y * cos
    }));
    
    return rotated;
  }

  // Player state
  const player = {
    x: 140,
    y: 300,
    vy: 0,
    vx: 300, // horizontal px/s (set per level)
    baseVx: 300, // base speed for the level
    alive: true,
    freezeTime: 0,
    angle: 0 // rotation angle in radians
  };

  // Trail system
  const trail = [];
  const MAX_TRAIL_LENGTH = 15;
  
  // Level state
  let levelWidth = 2500; // Will be set per level
  let levelComplete = false;
  
  // Speed scaling
  let gameStartTime = 0;
  let lastSpeedIncreaseTime = 0;

  // Physics (tap-to-flip mode)
  const physics = {
    verticalSpeed: 200, // constant vertical speed px/s
    horizontalSpeed: 300 // constant horizontal speed px/s
  };

  // Controls - Tap to Flip
  // Single click/tap flips vertical direction
  // Arrow continuously moves up or down until next tap
  let isMovingUp = true; // direction flag
  let inputActive = false; // disable during menus, enable during gameplay

  function flipDirection() {
    if (!inputActive) return;
    isMovingUp = !isMovingUp;
  }

  window.addEventListener('keydown', e=>{ 
    if ((e.code==='Space' || e.key===' ' || e.code==='KeyK') && inputActive) { 
      flipDirection();
      e.preventDefault(); 
    } 
  });
  
  canvas.addEventListener('pointerdown', (e)=>{ 
    if(inputActive) {
      flipDirection();
      e.preventDefault();
    }
  });

  // Flash overlay
  const flashEl = document.getElementById('flash');
  function flash(ms){
    flashEl.style.transition = 'none';
    flashEl.style.opacity = '1';
    setTimeout(()=>{ flashEl.style.transition = `opacity ${ms}ms ease`; flashEl.style.opacity = '0'; }, 20);
  }

  // Level obstacles
  // We'll define obstacles as polygons (triangles for spikes, rects for walls)
  function tri(x,y,w,h){ return {type:'tri',x,y,w,h}; }
  function rect(x,y,w,h){ return {type:'rect',x,y,w,h}; }

  // Generates level data per exact spec
  function makeLevel(n){
    const objs = [];
    const thickness = Math.round(40 * scale); // floor/ceiling thickness
    const spikeBase = Math.round(32 * scale); // spec: 32px
    const spikeHeight = Math.round(48 * scale); // spec: 48px
    const bigSpikeBase = Math.round(64 * scale); // big spike: double width
    const bigSpikeHeight = Math.round(H/2 - thickness); // half the vertical level
    const blockW = Math.round(128 * scale); // spec: 128px
    const blockH = Math.round(32 * scale); // spec: 32px
    const movingWallSize = Math.round(128 * scale); // spec: 128×128
    const laserWidth = Math.round(16 * scale);
    const dashPadW = Math.round(100 * scale);
    const dashPadH = Math.round(20 * scale);

    function addSpikeRowFloor(atX, count){
      for(let i=0;i<count;i++){
        objs.push({type:'tri',x:atX + i*spikeBase,y:H-thickness,w:spikeBase,h:spikeHeight,side:'floor',color:'#FF1744'});
      }
    }
    function addSpikeRowCeil(atX, count){
      for(let i=0;i<count;i++){
        objs.push({type:'tri',x:atX + i*spikeBase,y:thickness,w:spikeBase,h:spikeHeight,side:'ceiling',color:'#FF1744'});
      }
    }
    function addBigSpikeFloor(atX){
      objs.push({type:'tri',x:atX,y:H-thickness,w:bigSpikeBase,h:bigSpikeHeight,side:'floor',color:'#FF0000'});
    }
    function addBigSpikeCeil(atX){
      objs.push({type:'tri',x:atX,y:thickness,w:bigSpikeBase,h:bigSpikeHeight,side:'ceiling',color:'#FF0000'});
    }
    function addBlock(x,y,color='#5E35B1'){ objs.push({type:'rect',x,y,w:blockW,h:blockH,color}); }
    function addMovingWall(x,y,amp){
      objs.push({type:'movingWall',x0:x,y:y,x,w:movingWallSize,h:movingWallSize,amp,t:0,color:'#2979FF'});
    }
    function addBlinkingSpike(atX, side, freq = 2.0){
      objs.push({type:'blinkSpike', x:atX, y: side==='floor' ? H-thickness : thickness, w:spikeBase, h:spikeHeight, side, blinkFreq:freq, blinkPhase:0, visible:true,color:'#FFD700'});
    }
    function addDashPad(atX, side='floor'){
      const y = side === 'floor' ? H - thickness - dashPadH : thickness;
      objs.push({type:'dashPad', x:atX, y, w:dashPadW, h:dashPadH, side, color:'#FFEA00'});
    }
    function addLaser(x, startY, length, moveSpeed, vertical=true){
      objs.push({type:'laser', x, y:startY, x0:x, y0:startY, w:vertical?laserWidth:length, h:vertical?length:laserWidth, moveSpeed, moveOffset:0, vertical, color:'#E91E63'});
    }
    function addBouncePad(atX){
      objs.push({type:'bouncePad', x:atX, y:H-thickness-Math.round(30*scale), w:Math.round(80*scale), h:Math.round(30*scale), color:'#FF9800'});
    }
    function addGoal(atX){
      objs.push({type:'goal', x:atX, y:0, w:Math.round(80*scale), h:H});
    }

    // LEVEL 1 – WINDING HORIZONTAL PATH (300 px/s)
    if(n===1){
      player.vx = 300;
      player.baseVx = 300;
      levelWidth = 12000;
      
      // Section 1: Upper corridor - NO OVERLAPS
      addSpikeRowCeil(400, 2);
      addBigSpikeCeil(500);
      addBlock(580, H*0.25);
      addSpikeRowCeil(720, 3);
      addBlock(850, H*0.28);
      addBlinkingSpike(1000, 'ceiling', 2.0);
      addSpikeRowCeil(1100, 2);
      addBlock(1180, H*0.26);
      addBigSpikeCeil(1320);
      addSpikeRowCeil(1400, 2);
      addBlock(1500, H*0.27);
      
      // Section 2: Mid-lower corridor - NO OVERLAPS
      addSpikeRowFloor(1650, 3);
      addBlock(1770, H*0.65);
      addSpikeRowCeil(1920, 2);
      addBigSpikeFloor(2000);
      addBigSpikeCeil(2080);
      addBlock(2180, H*0.68);
      addSpikeRowFloor(2330, 2);
      addBlinkingSpike(2450, 'floor', 1.8);
      addSpikeRowCeil(2550, 3);
      addBlock(2680, H*0.63);
      addSpikeRowFloor(2820, 3);
      addMovingWall(2950, H*0.15, 35);
      addBigSpikeCeil(3080);
      
      // Section 3: Lower corridor - NO OVERLAPS
      addSpikeRowCeil(3220, 2);
      addBlock(3300, H*0.75);
      addSpikeRowFloor(3450, 3);
      addBigSpikeCeil(3580);
      addBigSpikeFloor(3660);
      addBlock(3750, H*0.73);
      addSpikeRowCeil(3900, 3);
      addBlinkingSpike(4030, 'ceiling', 2.1);
      addBlock(4150, H*0.76);
      addSpikeRowFloor(4280, 2);
      addMovingWall(4380, H*0.5, 40);
      addBigSpikeCeil(4500);
      addSpikeRowCeil(4600, 2);
      
      // Section 4: Mid corridor - NO OVERLAPS
      addSpikeRowFloor(4750, 3);
      addBlock(4880, H*0.55);
      addSpikeRowCeil(5020, 2);
      addBigSpikeFloor(5100);
      addBigSpikeCeil(5180);
      addDashPad(5270, 'floor');
      addBlock(5400, H*0.53);
      addSpikeRowFloor(5550, 2);
      addBlinkingSpike(5650, 'floor', 1.9);
      addSpikeRowCeil(5750, 3);
      addBlock(5880, H*0.57);
      addMovingWall(6020, H*0.15, 40);
      addBigSpikeFloor(6150);
      addSpikeRowFloor(6230, 2);
      
      // Section 5: Upper-mid corridor - NO OVERLAPS
      addSpikeRowCeil(6380, 3);
      addBlock(6520, H*0.35);
      addSpikeRowFloor(6660, 2);
      addBigSpikeCeil(6750);
      addBlock(6840, H*0.33);
      addSpikeRowCeil(6980, 4);
      addLaser(7100, H*0.55, H*0.2, 120, true);
      addBigSpikeFloor(7180);
      addBlock(7270, H*0.37);
      addSpikeRowFloor(7410, 3);
      addBlinkingSpike(7550, 'ceiling', 2.0);
      addSpikeRowCeil(7670, 2);
      addBlock(7780, H*0.34);
      addMovingWall(7920, H*0.65, 45);
      addBigSpikeCeil(8050);
      
      // Section 6: Mid-lower corridor - NO OVERLAPS
      addSpikeRowFloor(8200, 4);
      addBlock(8340, H*0.6);
      addSpikeRowCeil(8490, 3);
      addBigSpikeFloor(8620);
      addBigSpikeCeil(8700);
      addBlock(8810, H*0.62);
      addMovingWall(8950, H*0.35, 50);
      addSpikeRowFloor(9080, 3);
      addBlinkingSpike(9210, 'floor', 1.7);
      addSpikeRowCeil(9330, 2);
      addBlock(9440, H*0.58);
      addBigSpikeFloor(9570);
      addMovingWall(9680, H*0.15, 45);
      
      // Section 7: Lower corridor - NO OVERLAPS
      addSpikeRowCeil(9820, 3);
      addBlock(9950, H*0.72);
      addSpikeRowFloor(10100, 2);
      addBigSpikeCeil(10190);
      addBigSpikeFloor(10270);
      addBlock(10370, H*0.74);
      addSpikeRowCeil(10510, 2);
      addLaser(10620, H*0.4, H*0.25, 140, true);
      addSpikeRowFloor(10740, 3);
      addBlinkingSpike(10870, 'ceiling', 1.8);
      addBlock(10990, H*0.71);
      addSpikeRowCeil(11130, 2);
      addBlinkingSpike(11250, 'floor', 2.0);
      
      addGoal(levelWidth - 200);
    }
      
      // Section 2: Mid-lower corridor - HARDER
      addSpikeRowFloor(1600, 3);
      addSpikeRowCeil(1640, 2);
      addBigSpikeFloor(1700);
      addBigSpikeCeil(1720);
      addSpikeRowFloor(1850, 2);
      addSpikeRowCeil(1890, 3);
      addSpikeRowFloor(2000, 3);
      addBigSpikeFloor(2100);
      addSpikeRowCeil(2120, 2);
      addSpikeRowFloor(2250, 2);
      addSpikeRowCeil(2280, 3);
      addSpikeRowFloor(2450, 3);
      addBigSpikeCeil(2470);
      addBlock(1650, H*0.65);
      addBlock(1800, H*0.68);
      addBlock(1950, H*0.63);
      addBlock(2050, H*0.67);
      addBlock(2200, H*0.65);
      addBlock(2350, H*0.66);
      addBlinkingSpike(1750, 'floor', 1.8);
      addBlinkingSpike(2150, 'floor', 2.0);
      addLaser(1900, H*0.35, H*0.25, 100, true);
      addMovingWall(2300, H*0.15, 35);
      
      // Section 3: Lower corridor - HARDER
      addSpikeRowCeil(2700, 2);
      addSpikeRowFloor(2720, 3);
      addBigSpikeCeil(2780);
      addBigSpikeFloor(2800);
      addSpikeRowCeil(2920, 3);
      addSpikeRowFloor(2950, 2);
      addSpikeRowCeil(3100, 2);
      addSpikeRowFloor(3130, 3);
      addBigSpikeCeil(3180);
      addSpikeRowCeil(3300, 2);
      addBigSpikeFloor(3320);
      addBlock(2750, H*0.75);
      addBlock(2900, H*0.73);
      addBlock(3000, H*0.76);
      addBlock(3150, H*0.74);
      addBlock(3250, H*0.77);
      addBlock(3350, H*0.75);
      addBlinkingSpike(2850, 'ceiling', 2.1);
      addBlinkingSpike(3200, 'floor', 2.0);
      addMovingWall(3050, H*0.5, 40);
      
      // Section 4: Mid corridor - HARDER
      addSpikeRowFloor(3500, 3);
      addSpikeRowCeil(3530, 2);
      addBigSpikeFloor(3600);
      addBigSpikeCeil(3620);
      addSpikeRowFloor(3720, 2);
      addSpikeRowCeil(3750, 3);
      addSpikeRowFloor(3900, 3);
      addSpikeRowCeil(3930, 2);
      addBigSpikeFloor(4000);
      addBigSpikeCeil(4020);
      addSpikeRowFloor(4120, 2);
      addSpikeRowCeil(4150, 3);
      addBlock(3550, H*0.55);
      addBlock(3680, H*0.53);
      addBlock(3800, H*0.57);
      addBlock(3950, H*0.54);
      addBlock(4070, H*0.56);
      addBlock(4150, H*0.55);
      addDashPad(3650, 'floor');
      addBlinkingSpike(3850, 'floor', 1.9);
      addMovingWall(3850, H*0.15, 40);
      
      // Section 5: Upper-mid corridor - HARDER
      addSpikeRowCeil(4300, 3);
      addSpikeRowFloor(4330, 2);
      addBigSpikeCeil(4400);
      addBigSpikeFloor(4420);
      addSpikeRowCeil(4550, 4);
      addSpikeRowFloor(4590, 3);
      addBigSpikeCeil(4720);
      addSpikeRowFloor(4750, 2);
      addSpikeRowCeil(4850, 3);
      addSpikeRowFloor(4880, 3);
      addSpikeRowCeil(5050, 4);
      addBigSpikeCeil(5220);
      addBigSpikeFloor(5240);
      addBlock(4350, H*0.35);
      addBlock(4480, H*0.33);
      addBlock(4620, H*0.37);
      addBlock(4760, H*0.34);
      addBlock(4900, H*0.36);
      addBlock(5050, H*0.35);
      addBlock(5180, H*0.38);
      addLaser(4500, H*0.55, H*0.2, 120, true);
      addBlinkingSpike(4950, 'ceiling', 2.0);
      addMovingWall(4650, H*0.65, 45);
      
      // Section 6: Mid-lower corridor - HARDER
      addSpikeRowFloor(5400, 4);
      addSpikeRowCeil(5440, 3);
      addBigSpikeFloor(5530);
      addBigSpikeCeil(5550);
      addSpikeRowFloor(5650, 3);
      addSpikeRowCeil(5680, 2);
      addSpikeRowFloor(5850, 4);
      addSpikeRowCeil(5890, 3);
      addBigSpikeFloor(5980);
      addBigSpikeCeil(6000);
      addBlock(5450, H*0.6);
      addBlock(5580, H*0.62);
      addBlock(5710, H*0.58);
      addBlock(5820, H*0.61);
      addBlock(5950, H*0.59);
      addBlock(6050, H*0.6);
      addMovingWall(5700, H*0.35, 50);
      addMovingWall(5900, H*0.15, 45);
      addBlinkingSpike(5750, 'floor', 1.7);
      
      // Section 7: Lower corridor - HARDER
      addSpikeRowCeil(6100, 3);
      addSpikeRowFloor(6130, 2);
      addBigSpikeCeil(6200);
      addBigSpikeFloor(6220);
      addSpikeRowCeil(6320, 2);
      addSpikeRowFloor(6350, 3);
      addSpikeRowCeil(6500, 3);
      addSpikeRowFloor(6540, 2);
      addBigSpikeCeil(6610);
      addBigSpikeFloor(6630);
      addSpikeRowCeil(6730, 2);
      addSpikeRowFloor(6760, 3);
      addSpikeRowCeil(6900, 3);
      addSpikeRowFloor(6930, 2);
      addBlock(6150, H*0.72);
      addBlock(6270, H*0.74);
      addBlock(6390, H*0.71);
      addBlock(6520, H*0.73);
      addBlock(6650, H*0.75);
      addBlock(6770, H*0.72);
      addBlock(6880, H*0.74);
      addLaser(6400, H*0.4, H*0.25, 140, true);
      addBlinkingSpike(6550, 'ceiling', 1.8);
      addBlinkingSpike(6800, 'floor', 2.0);
      
      // Section 8: Mid corridor - HARDER
      addSpikeRowFloor(7050, 4);
      addSpikeRowCeil(7090, 3);
      addBigSpikeFloor(7190);
      addBigSpikeCeil(7210);
      addSpikeRowFloor(7310, 3);
      addSpikeRowCeil(7350, 2);
      addSpikeRowFloor(7520, 4);
      addSpikeRowCeil(7560, 3);
      addBigSpikeFloor(7660);
      addBigSpikeCeil(7680);
      addBlock(7100, H*0.52);
      addBlock(7230, H*0.54);
      addBlock(7360, H*0.51);
      addBlock(7480, H*0.53);
      addBlock(7610, H*0.52);
      addBlock(7720, H*0.55);
      addMovingWall(7300, H*0.28, 45);
      addMovingWall(7550, H*0.72, 40);
      addDashPad(7450, 'floor');
      
      // Section 9: Upper corridor - HARDER
      addSpikeRowCeil(7800, 4);
      addSpikeRowFloor(7840, 3);
      addBigSpikeCeil(7940);
      addBigSpikeFloor(7960);
      addSpikeRowCeil(8060, 5);
      addSpikeRowFloor(8100, 2);
      addBigSpikeCeil(8230);
      addBigSpikeFloor(8250);
      addSpikeRowCeil(8350, 4);
      addSpikeRowFloor(8390, 3);
      addBigSpikeCeil(8490);
      addBigSpikeFloor(8510);
      addSpikeRowCeil(8600, 3);
      addSpikeRowFloor(8640, 2);
      addBlock(7850, H*0.28);
      addBlock(7980, H*0.26);
      addBlock(8110, H*0.29);
      addBlock(8240, H*0.27);
      addBlock(8380, H*0.28);
      addBlock(8520, H*0.3);
      addBlock(8650, H*0.28);
      addBlinkingSpike(8000, 'ceiling', 2.2);
      addBlinkingSpike(8400, 'ceiling', 1.9);
      addLaser(8200, H*0.5, H*0.2, 130, true);
      addMovingWall(8450, H*0.65, 50);
      
      // Section 10: Mid-upper corridor - HARDER
      addSpikeRowFloor(8750, 3);
      addSpikeRowCeil(8790, 2);
      addBigSpikeFloor(8850);
      addBigSpikeCeil(8870);
      addSpikeRowFloor(8970, 4);
      addSpikeRowCeil(9010, 3);
      addBigSpikeFloor(9110);
      addBigSpikeCeil(9130);
      addSpikeRowFloor(9230, 3);
      addSpikeRowCeil(9270, 2);
      addBlock(8800, H*0.62);
      addBlock(8920, H*0.64);
      addBlock(9040, H*0.61);
      addBlock(9160, H*0.63);
      addBlock(9280, H*0.62);
      addMovingWall(9000, H*0.38, 55);
      addMovingWall(9200, H*0.15, 45);
      addBlinkingSpike(9050, 'floor', 2.0);
      
      // Section 11: Upper corridor - HARDER
      addSpikeRowCeil(9350, 3);
      addSpikeRowFloor(9390, 2);
      addBigSpikeCeil(9450);
      addBigSpikeFloor(9470);
      addSpikeRowCeil(9570, 4);
      addSpikeRowFloor(9610, 3);
      addBigSpikeCeil(9710);
      addBigSpikeFloor(9730);
      addSpikeRowCeil(9830, 3);
      addSpikeRowFloor(9870, 2);
      addBlock(9400, H*0.3);
      addBlock(9520, H*0.32);
      addBlock(9640, H*0.29);
      addBlock(9760, H*0.31);
      addBlock(9880, H*0.3);
      addLaser(9600, H*0.55, H*0.22, 150, true);
      addBlinkingSpike(9750, 'ceiling', 1.8);
      addMovingWall(9550, H*0.68, 50);
      
      // Section 12: Mid corridor - HARDER
      addSpikeRowFloor(10050, 4);
      addSpikeRowCeil(10090, 3);
      addBigSpikeFloor(10190);
      addBigSpikeCeil(10210);
      addSpikeRowFloor(10310, 3);
      addSpikeRowCeil(10350, 2);
      addSpikeRowFloor(10500, 4);
      addSpikeRowCeil(10540, 3);
      addBigSpikeFloor(10640);
      addBigSpikeCeil(10660);
      addBlock(10100, H*0.58);
      addBlock(10230, H*0.56);
      addBlock(10360, H*0.59);
      addBlock(10480, H*0.57);
      addBlock(10610, H*0.58);
      addBlock(10720, H*0.6);
      addMovingWall(10400, H*0.32, 60);
      addMovingWall(10550, H*0.68, 50);
      addDashPad(10250, 'floor');
      
      // Section 13: Final stretch - HARDER
      addSpikeRowCeil(10800, 5);
      addBigSpikeCeil(10970);
      addSpikeRowCeil(11090, 4);
      addSpikeRowFloor(10850, 3);
      addBigSpikeFloor(10970);
      addSpikeRowFloor(11120, 3);
      addBlock(10850, H*0.35);
      addBlock(10970, H*0.65);
      addBlock(11090, H*0.37);
      addBlock(11200, H*0.33);
      addBlock(11320, H*0.35);
      addLaser(11000, H*0.5, H*0.3, 160, true);
      addBlinkingSpike(11150, 'ceiling', 2.5);
      addBlinkingSpike(11150, 'floor', 2.5);
      addMovingWall(11250, H*0.35, 70);
      
      addGoal(levelWidth - 200);
    }
    // LEVEL 2 – BITE CORRIDOR (340 px/s) - NO CAMPING
    else if(n===2){
      player.vx = 340;
      player.baseVx = 340;
      levelWidth = 6500;
      
      // Opening gauntlet - alternating spikes
      addSpikeRowCeil(400, 3);
      addSpikeRowFloor(450, 4);
      addBigSpikeCeil(550);
      addBigSpikeFloor(570);
      addSpikeRowCeil(650, 5);
      addSpikeRowFloor(700, 3);
      addBigSpikeCeil(800);
      addBigSpikeFloor(820);
      addBlock(500, H*0.4);
      addBlock(620, H*0.6);
      addBlock(750, H*0.35);
      addBlock(850, H*0.65);
      
      // Laser + spike combo
      addLaser(1000, H*0.2, H*0.25, 150, true);
      addSpikeRowFloor(1050, 4);
      addSpikeRowCeil(1100, 3);
      addBigSpikeCeil(1200);
      addBigSpikeFloor(1220);
      addBlock(1100, H*0.5);
      addBlock(1250, H*0.38);
      addMovingWall(1150, H*0.55, 45);
      
      // Dense spike section
      addSpikeRowCeil(1400, 6);
      addSpikeRowFloor(1480, 5);
      addBigSpikeCeil(1600);
      addBigSpikeFloor(1620);
      addSpikeRowCeil(1720, 4);
      addSpikeRowFloor(1800, 6);
      addBlock(1450, H*0.32);
      addBlock(1570, H*0.68);
      addBlock(1700, H*0.4);
      addBlock(1850, H*0.6);
      addBlinkingSpike(1550, 'ceiling', 2.0);
      addBlinkingSpike(1750, 'floor', 1.8);
      
      // Moving walls + spikes
      addMovingWall(2000, H*0.25, 60);
      addSpikeRowFloor(2050, 5);
      addSpikeRowCeil(2100, 4);
      addBigSpikeCeil(2200);
      addBigSpikeFloor(2220);
      addMovingWall(2300, H*0.6, 55);
      addSpikeRowCeil(2350, 3);
      addSpikeRowFloor(2400, 4);
      addBlock(2080, H*0.5);
      addBlock(2250, H*0.35);
      
      // Dash pad + spike gauntlet
      addDashPad(2550, 'floor');
      addSpikeRowCeil(2600, 7);
      addSpikeRowFloor(2700, 6);
      addBigSpikeCeil(2820);
      addBigSpikeFloor(2840);
      addSpikeRowCeil(2950, 4);
      addSpikeRowFloor(3000, 5);
      addBlock(2650, H*0.42);
      addBlock(2780, H*0.58);
      addBlock(2920, H*0.36);
      
      // Blinking spike maze
      for(let i=0; i<8; i++){
        addBlinkingSpike(3200 + i*100, i%2===0?'ceiling':'floor', 1.8 + (i%3)*0.3);
        if(i%2===0) {
          addSpikeRowFloor(3230 + i*100, 2);
          addBigSpikeCeil(3280 + i*100);
        } else {
          addSpikeRowCeil(3230 + i*100, 2);
          addBigSpikeFloor(3280 + i*100);
        }
        addBlock(3250 + i*100, H*0.5);
      }
      
      // Laser grid + spikes
      addLaser(4100, H*0.25, H*0.3, 180, true);
      addLaser(4250, H*0.45, H*0.3, 160, true);
      addSpikeRowCeil(4150, 5);
      addSpikeRowFloor(4200, 4);
      addBigSpikeCeil(4320);
      addBigSpikeFloor(4340);
      addSpikeRowCeil(4420, 3);
      addSpikeRowFloor(4480, 5);
      addBlock(4180, H*0.6);
      addBlock(4300, H*0.35);
      addBlock(4450, H*0.65);
      
      // Moving wall chaos
      addMovingWall(4650, H*0.3, 65);
      addMovingWall(4850, H*0.65, 70);
      addSpikeRowCeil(4700, 6);
      addSpikeRowFloor(4750, 5);
      addBigSpikeCeil(4900);
      addBigSpikeFloor(4920);
      addSpikeRowCeil(5000, 4);
      addSpikeRowFloor(5050, 6);
      addBlock(4750, H*0.45);
      addBlock(4950, H*0.55);
      
      // Final gauntlet
      addSpikeRowCeil(5250, 8);
      addSpikeRowFloor(5350, 7);
      addBigSpikeCeil(5480);
      addBigSpikeFloor(5500);
      addSpikeRowCeil(5600, 6);
      addSpikeRowFloor(5680, 8);
      addBigSpikeCeil(5850);
      addBigSpikeFloor(5870);
      addBlock(5300, H*0.38);
      addBlock(5420, H*0.62);
      addBlock(5550, H*0.42);
      addBlock(5750, H*0.58);
      addBlinkingSpike(5400, 'ceiling', 2.5);
      addBlinkingSpike(5700, 'floor', 2.3);
      addLaser(5650, H*0.5, H*0.25, 200, true);
      addMovingWall(5950, H*0.4, 75);
      
      addGoal(levelWidth - 200);
    }
    // LEVEL 3 – FLOATING GEOMETRY (380 px/s) - NO CAMPING
    else if(n===3){
      player.vx = 380;
      player.baseVx = 380;
      levelWidth = 7000;
      
      // Opening dense section
      addBlock(500, H*0.3);
      addSpikeRowFloor(550, 4);
      addSpikeRowCeil(600, 3);
      addBigSpikeCeil(700);
      addBigSpikeFloor(720);
      addBlock(650, H*0.65);
      addBlock(770, H*0.38);
      addSpikeRowCeil(850, 5);
      addSpikeRowFloor(900, 4);
      addBlock(950, H*0.55);
      
      // Laser + spike section
      addLaser(1100, H*0.2, H*0.28, 120, true);
      addSpikeRowFloor(1150, 6);
      addBigSpikeCeil(1250);
      addBigSpikeFloor(1270);
      addSpikeRowCeil(1350, 4);
      addBlock(1200, H*0.45);
      addBlock(1320, H*0.62);
      addMovingWall(1400, H*0.35, 50);
      
      // Bounce pad + obstacles
      addBouncePad(1600);
      addSpikeRowCeil(1650, 7);
      addBigSpikeCeil(1780);
      addSpikeRowFloor(1830, 5);
      addBigSpikeFloor(1950);
      addBlock(1720, H*0.28);
      addBlock(1880, H*0.72);
      addBlock(2000, H*0.42);
      addBlinkingSpike(1800, 'ceiling', 1.9);
      addBlinkingSpike(1950, 'floor', 2.1);
      
      // Dense laser grid
      addLaser(2150, H*0.25, H*0.3, 140, true);
      addLaser(2300, H*0.45, H*0.3, 130, true);
      addSpikeRowCeil(2200, 6);
      addSpikeRowFloor(2250, 5);
      addBigSpikeCeil(2380);
      addBigSpikeFloor(2400);
      addSpikeRowCeil(2480, 4);
      addSpikeRowFloor(2530, 6);
      addBlock(2230, H*0.58);
      addBlock(2350, H*0.35);
      addBlock(2500, H*0.68);
      
      // Dash + spike combo
      addDashPad(2700, 'floor');
      addSpikeRowCeil(2750, 8);
      addSpikeRowFloor(2850, 7);
      addBigSpikeCeil(2980);
      addBigSpikeFloor(3000);
      addSpikeRowCeil(3100, 5);
      addSpikeRowFloor(3150, 6);
      addBlock(2800, H*0.38);
      addBlock(2950, H*0.62);
      addBlock(3080, H*0.45);
      addMovingWall(2900, H*0.25, 60);
      
      // Blinking spike maze
      for(let i=0; i<10; i++){
        addBlinkingSpike(3350 + i*90, i%2===0?'floor':'ceiling', 1.7 + (i%4)*0.2);
        if(i%2===0){
          addSpikeRowCeil(3380 + i*90, 3);
          addBigSpikeFloor(3430 + i*90);
        } else {
          addSpikeRowFloor(3380 + i*90, 3);
          addBigSpikeCeil(3430 + i*90);
        }
        addBlock(3400 + i*90, H*0.5);
      }
      
      // Moving wall chaos
      addMovingWall(4400, H*0.28, 70);
      addMovingWall(4600, H*0.62, 65);
      addSpikeRowCeil(4450, 7);
      addSpikeRowFloor(4520, 6);
      addBigSpikeCeil(4650);
      addBigSpikeFloor(4670);
      addSpikeRowCeil(4750, 5);
      addSpikeRowFloor(4800, 7);
      addBlock(4500, H*0.42);
      addBlock(4630, H*0.58);
      addBlock(4750, H*0.35);
      addLaser(4550, H*0.5, H*0.25, 150, true);
      
      // Platform section
      addBouncePad(5000);
      addBlock(5100, H*0.25);
      addSpikeRowFloor(5150, 8);
      addBigSpikeCeil(5280);
      addBlock(5220, H*0.68);
      addSpikeRowCeil(5350, 6);
      addBigSpikeFloor(5450);
      addBlock(5400, H*0.42);
      addSpikeRowFloor(5520, 5);
      addMovingWall(5550, H*0.55, 55);
      
      // Final gauntlet
      addLaser(5750, H*0.3, H*0.35, 180, true);
      addSpikeRowCeil(5800, 9);
      addSpikeRowFloor(5900, 8);
      addBigSpikeCeil(6050);
      addBigSpikeFloor(6070);
      addSpikeRowCeil(6180, 7);
      addSpikeRowFloor(6260, 9);
      addBigSpikeCeil(6420);
      addBigSpikeFloor(6440);
      addBlock(5850, H*0.48);
      addBlock(6020, H*0.52);
      addBlock(6200, H*0.38);
      addBlock(6400, H*0.62);
      addBlinkingSpike(6100, 'ceiling', 2.5);
      addBlinkingSpike(6300, 'floor', 2.3);
      addMovingWall(6500, H*0.4, 80);
      
      addGoal(levelWidth - 200);
    }
    // LEVEL 4 – THE TEETH (430 px/s) - NO CAMPING
    else if(n===4){
      player.vx = 430;
      player.baseVx = 430;
      levelWidth = 7500;
      
      // Every section has both ceiling AND floor spikes to prevent camping
      addSpikeRowCeil(500, 5);
      addSpikeRowFloor(550, 6);
      addBigSpikeCeil(650);
      addBigSpikeFloor(670);
      addSpikeRowCeil(750, 7);
      addSpikeRowFloor(820, 8);
      addBlock(600, H*0.42);
      addBlock(720, H*0.58);
      addBlock(880, H*0.38);
      
      addSpikeRowFloor(1000, 9);
      addSpikeRowCeil(1100, 8);
      addBigSpikeFloor(1220);
      addBigSpikeCeil(1240);
      addSpikeRowFloor(1340, 7);
      addSpikeRowCeil(1420, 9);
      addBlock(1050, H*0.62);
      addBlock(1200, H*0.45);
      addBlock(1380, H*0.55);
      addMovingWall(1150, H*0.3, 55);
      addMovingWall(1300, H*0.65, 50);
      
      addLaser(1550, H*0.25, H*0.3, 170, true);
      addSpikeRowCeil(1600, 10);
      addSpikeRowFloor(1700, 9);
      addBigSpikeCeil(1830);
      addBigSpikeFloor(1850);
      addSpikeRowCeil(1950, 8);
      addSpikeRowFloor(2030, 10);
      addBlock(1650, H*0.48);
      addBlock(1800, H*0.52);
      addBlock(2000, H*0.38);
      
      addDashPad(2200, 'floor');
      addSpikeRowCeil(2250, 12);
      addSpikeRowFloor(2380, 11);
      addBigSpikeCeil(2530);
      addBigSpikeFloor(2550);
      addSpikeRowCeil(2650, 9);
      addSpikeRowFloor(2730, 12);
      addBlock(2300, H*0.42);
      addBlock(2500, H*0.58);
      addBlock(2700, H*0.45);
      
      for(let i=0; i<10; i++){
        addBlinkingSpike(3000 + i*90, i%2===0?'ceiling':'floor', 2.2 + (i%3)*0.3);
        if(i%2===0){
          addSpikeRowFloor(3030 + i*90, 4);
          addBigSpikeCeil(3080 + i*90);
        } else {
          addSpikeRowCeil(3030 + i*90, 4);
          addBigSpikeFloor(3080 + i*90);
        }
        addBlock(3050 + i*90, H*0.5);
      }
      
      addMovingWall(4000, H*0.28, 70);
      addMovingWall(4200, H*0.62, 65);
      addSpikeRowCeil(4050, 11);
      addSpikeRowFloor(4150, 10);
      addBigSpikeCeil(4280);
      addBigSpikeFloor(4300);
      addSpikeRowCeil(4400, 9);
      addSpikeRowFloor(4480, 11);
      addBlock(4100, H*0.45);
      addBlock(4270, H*0.55);
      addBlock(4450, H*0.38);
      
      addBouncePad(4700);
      addSpikeRowCeil(4750, 13);
      addSpikeRowFloor(4900, 12);
      addBigSpikeCeil(5050);
      addBigSpikeFloor(5070);
      addSpikeRowCeil(5180, 10);
      addSpikeRowFloor(5280, 13);
      addBlock(4800, H*0.32);
      addBlock(5020, H*0.68);
      addBlock(5230, H*0.42);
      
      addLaser(5450, H*0.25, H*0.35, 200, true);
      addLaser(5650, H*0.4, H*0.35, 190, true);
      addSpikeRowFloor(5500, 14);
      addSpikeRowCeil(5620, 13);
      addBigSpikeFloor(5780);
      addBigSpikeCeil(5800);
      addSpikeRowFloor(5920, 12);
      addSpikeRowCeil(6030, 14);
      addBlock(5550, H*0.52);
      addBlock(5750, H*0.48);
      addBlock(6000, H*0.38);
      
      addSpikeRowCeil(6250, 16);
      addSpikeRowFloor(6400, 15);
      addBigSpikeCeil(6580);
      addBigSpikeFloor(6600);
      addSpikeRowCeil(6750, 14);
      addSpikeRowFloor(6880, 16);
      addBlock(6320, H*0.42);
      addBlock(6550, H*0.58);
      addBlock(6830, H*0.45);
      addBlinkingSpike(6500, 'ceiling', 2.8);
      addBlinkingSpike(6700, 'floor', 2.6);
      addMovingWall(6650, H*0.35, 80);
      
      addGoal(levelWidth - 200);
    }
    // LEVEL 5 – CRUSH CORRIDOR (510 px/s) - NO CAMPING
    else if(n===5){
      player.vx = 510;
      player.baseVx = 510;
      levelWidth = 8000;
      
      // Maximum density - no camping possible
      addLaser(500, H*0.22, H*0.3, 200, true);
      addSpikeRowCeil(550, 8);
      addSpikeRowFloor(630, 9);
      addBigSpikeCeil(770);
      addBigSpikeFloor(790);
      addSpikeRowCeil(880, 10);
      addSpikeRowFloor(980, 8);
      addBlock(600, H*0.45);
      addBlock(740, H*0.55);
      addBlock(930, H*0.42);
      
      for(let i=0; i<8; i++){
        addSpikeRowCeil(1200 + i*180, 5);
        addSpikeRowFloor(1260 + i*180, 6);
        addBigSpikeCeil(1350 + i*180);
        addBigSpikeFloor(1370 + i*180);
        addBlock(1250 + i*180, H*0.5);
        if(i%2===0) addMovingWall(1300 + i*180, H*0.3, 50 + i*5);
        else addMovingWall(1300 + i*180, H*0.65, 50 + i*5);
      }
      
      addDashPad(2700, 'floor');
      addSpikeRowCeil(2750, 14);
      addSpikeRowFloor(2900, 13);
      addBigSpikeCeil(3070);
      addBigSpikeFloor(3090);
      addSpikeRowCeil(3200, 12);
      addSpikeRowFloor(3310, 14);
      addBlock(2800, H*0.42);
      addBlock(3050, H*0.58);
      addBlock(3270, H*0.45);
      
      addDashPad(3500, 'ceiling');
      addSpikeRowFloor(3550, 15);
      addSpikeRowCeil(3700, 14);
      addBigSpikeFloor(3880);
      addBigSpikeCeil(3900);
      addSpikeRowFloor(4020, 13);
      addSpikeRowCeil(4130, 15);
      addBlock(3600, H*0.62);
      addBlock(3850, H*0.38);
      addBlock(4100, H*0.55);
      
      for(let i=0; i<12; i++){
        addBlinkingSpike(4350 + i*85, i%2===0?'floor':'ceiling', 2.5 + (i%4)*0.3);
        if(i%2===0){
          addSpikeRowCeil(4380 + i*85, 5);
          addBigSpikeFloor(4430 + i*85);
        } else {
          addSpikeRowFloor(4380 + i*85, 5);
          addBigSpikeCeil(4430 + i*85);
        }
        addBlock(4400 + i*85, H*0.5);
      }
      
      addMovingWall(5450, H*0.25, 75);
      addMovingWall(5650, H*0.6, 70);
      addSpikeRowCeil(5500, 16);
      addSpikeRowFloor(5620, 15);
      addBigSpikeCeil(5800);
      addBigSpikeFloor(5820);
      addSpikeRowCeil(5950, 14);
      addSpikeRowFloor(6060, 16);
      addBlock(5550, H*0.48);
      addBlock(5780, H*0.52);
      addBlock(6020, H*0.38);
      
      addLaser(6250, H*0.25, H*0.35, 210, true);
      addLaser(6450, H*0.4, H*0.35, 200, true);
      addSpikeRowFloor(6300, 17);
      addSpikeRowCeil(6420, 16);
      addBigSpikeFloor(6600);
      addBigSpikeCeil(6620);
      addSpikeRowFloor(6750, 15);
      addSpikeRowCeil(6870, 17);
      addBlock(6350, H*0.52);
      addBlock(6580, H*0.48);
      addBlock(6830, H*0.42);
      
      addBouncePad(7050);
      addSpikeRowCeil(7100, 18);
      addSpikeRowFloor(7260, 17);
      addBigSpikeCeil(7450);
      addBigSpikeFloor(7470);
      addSpikeRowCeil(7600, 16);
      addSpikeRowFloor(7730, 18);
      addBlock(7150, H*0.28);
      addBlock(7420, H*0.72);
      addBlock(7680, H*0.45);
      addBlinkingSpike(7300, 'ceiling', 3.0);
      addBlinkingSpike(7550, 'floor', 2.8);
      addMovingWall(7500, H*0.5, 85);
      
      addGoal(levelWidth - 200);
    }
    // LEVEL 6 – FINAL GAUNTLET (560 px/s) - NO CAMPING
    else if(n===6){
      player.vx = 560;
      player.baseVx = 560;
      levelWidth = 9000;
      
      addGoal(levelWidth - 200);
    }
    // LEVEL 6 – FINAL GAUNTLET (560 px/s) - NO CAMPING
    else if(n===6){
      player.vx = 560;
      player.baseVx = 560;
      levelWidth = 9000;
      
      // Ultimate difficulty - every inch is deadly
      for(let i=0; i<15; i++){
        if(i%2===0){
          addSpikeRowCeil(500 + i*120, 7);
          addSpikeRowFloor(550 + i*120, 8);
          addBigSpikeCeil(680 + i*120);
          addBlock(600 + i*120, H*0.42);
        } else {
          addSpikeRowFloor(500 + i*120, 8);
          addSpikeRowCeil(550 + i*120, 7);
          addBigSpikeFloor(680 + i*120);
          addBlock(600 + i*120, H*0.58);
        }
        if(i%3===0) addMovingWall(620 + i*120, i%2===0 ? H*0.3 : H*0.65, 55 + i*3);
      }
      
      addLaser(2300, H*0.25, H*0.35, 190, true);
      addLaser(2500, H*0.4, H*0.35, 200, true);
      addSpikeRowCeil(2350, 12);
      addSpikeRowFloor(2470, 13);
      addBigSpikeCeil(2650);
      addBigSpikeFloor(2670);
      addSpikeRowCeil(2800, 11);
      addSpikeRowFloor(2920, 12);
      addBlock(2400, H*0.48);
      addBlock(2620, H*0.52);
      addBlock(2880, H*0.42);
      
      addDashPad(3100, 'floor');
      addSpikeRowCeil(3150, 18);
      addSpikeRowFloor(3320, 17);
      addBigSpikeCeil(3520);
      addBigSpikeFloor(3540);
      addSpikeRowCeil(3680, 16);
      addSpikeRowFloor(3820, 18);
      addBlock(3200, H*0.38);
      addBlock(3500, H*0.62);
      addBlock(3780, H*0.45);
      
      addDashPad(4000, 'ceiling');
      addSpikeRowFloor(4050, 19);
      addSpikeRowCeil(4240, 18);
      addBigSpikeFloor(4450);
      addBigSpikeCeil(4470);
      addSpikeRowFloor(4620, 17);
      addSpikeRowCeil(4770, 19);
      addBlock(4100, H*0.68);
      addBlock(4420, H*0.32);
      addBlock(4730, H*0.55);
      
      for(let i=0; i<14; i++){
        addBlinkingSpike(5000 + i*80, i%2===0?'ceiling':'floor', 2.8 + (i%4)*0.3);
        if(i%2===0){
          addSpikeRowFloor(5030 + i*80, 6);
          addBigSpikeCeil(5080 + i*80);
        } else {
          addSpikeRowCeil(5030 + i*80, 6);
          addBigSpikeFloor(5080 + i*80);
        }
        addBlock(5050 + i*80, H*0.5);
      }
      
      addMovingWall(6200, H*0.25, 80);
      addMovingWall(6400, H*0.6, 75);
      addMovingWall(6600, H*0.35, 70);
      addSpikeRowCeil(6250, 20);
      addSpikeRowFloor(6400, 19);
      addBigSpikeCeil(6620);
      addBigSpikeFloor(6640);
      addSpikeRowCeil(6780, 18);
      addSpikeRowFloor(6920, 20);
      addBlock(6300, H*0.42);
      addBlock(6600, H*0.58);
      addBlock(6880, H*0.38);
      
      addBouncePad(7150);
      addLaser(7200, H*0.25, H*0.4, 220, true);
      addSpikeRowCeil(7250, 22);
      addSpikeRowFloor(7430, 21);
      addBigSpikeCeil(7650);
      addBigSpikeFloor(7670);
      addLaser(7750, H*0.35, H*0.4, 210, true);
      addSpikeRowCeil(7820, 20);
      addSpikeRowFloor(7980, 22);
      addBlock(7300, H*0.32);
      addBlock(7620, H*0.68);
      addBlock(7940, H*0.45);
      
      addSpikeRowCeil(8200, 25);
      addSpikeRowFloor(8400, 24);
      addBigSpikeCeil(8650);
      addBigSpikeFloor(8670);
      addSpikeRowCeil(8820, 23);
      addSpikeRowFloor(9000, 25);
      addBlock(8280, H*0.48);
      addBlock(8620, H*0.52);
      addBlock(8900, H*0.42);
      addBlinkingSpike(8450, 'ceiling', 3.5);
      addBlinkingSpike(8700, 'floor', 3.3);
      addMovingWall(8500, H*0.38, 90);
      addMovingWall(8750, H*0.62, 85);
      
      addGoal(levelWidth - 200);
    }

    // Floor and ceiling slabs
    objs.push({type:'slab',x:-1000,y:0,w:10000,h:thickness,which:'ceiling'});
    objs.push({type:'slab',x:-1000,y:H-thickness,w:10000,h:thickness,which:'floor'});
    return objs;
  }

  let obstacles = makeLevel(currentLevel);

  // Collision helpers
  function pointInTriangle(px,py, a,b,c){
    const area = (p,q,r)=> (q.x-p.x)*(r.y-p.y)-(q.y-p.y)*(r.x-p.x);
    const w1 = area({x:px,y:py}, b, c);
    const w2 = area({x:px,y:py}, c, a);
    const w3 = area({x:px,y:py}, a, b);
    const sameSigns = (x,y)=> (x>=0 && y>=0) || (x<=0 && y<=0);
    return sameSigns(w1,w2) && sameSigns(w2,w3);
  }
  function rectTriCollision(r, triPts){
    // Check if any tri point is inside rect or any rect corner inside triangle
    for(const p of triPts){ if(p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h) return true; }
    // rect corners
    const corners = [{x:r.x,y:r.y},{x:r.x+r.w,y:r.y},{x:r.x,y:r.y+r.h},{x:r.x+r.w,y:r.y+r.h}];
    for(const c of corners) if(pointInTriangle(c.x,c.y, triPts[0],triPts[1],triPts[2])) return true;
    return false;
  }

  // Update loop
  let last = performance.now();
  let gameTime = 0;
  function update(now){
    const dt = Math.min((now-last)/1000, 0.033);
    last = now;
    gameTime += dt;
    
    if(player.freezeTime > 0){
      player.freezeTime -= dt;
      draw();
      requestAnimationFrame(update);
      return;
    }

    if(running && player.alive){
      // === PROGRESSIVE DIFFICULTY ===
      // Increase speed by 10% every 10 seconds
      const currentTime = performance.now();
      if(gameStartTime === 0) gameStartTime = currentTime;
      
      const timeElapsed = (currentTime - gameStartTime) / 1000; // in seconds
      const speedIncreaseInterval = 10; // seconds
      
      if(timeElapsed - lastSpeedIncreaseTime >= speedIncreaseInterval){
        player.vx = player.baseVx * Math.pow(1.1, Math.floor(timeElapsed / speedIncreaseInterval));
        lastSpeedIncreaseTime = Math.floor(timeElapsed / speedIncreaseInterval) * speedIncreaseInterval;
      }
      
      // === TAP-TO-FLIP MECHANIC ===
      // Arrow moves at constant vertical speed, either up or down
      // Single tap flips direction instantly
      // No gravity or acceleration - uniform motion
      
      if(isMovingUp){
        // Moving upward at constant speed
        // Screen coords: negative Y = up
        player.y -= physics.verticalSpeed * dt;
        player.angle = -Math.PI / 8; // Tilt up (about -22.5 degrees)
      } else {
        // Moving downward at constant speed
        // Screen coords: positive Y = down
        player.y += physics.verticalSpeed * dt;
        player.angle = Math.PI / 8; // Tilt down (about +22.5 degrees)
      }

      // Add position to trail
      trail.push({x: player.x, y: player.y, angle: player.angle});
      if(trail.length > MAX_TRAIL_LENGTH) trail.shift();
      
      // Horizontal movement: shift world left
      const shift = player.vx * dt;
      for(const o of obstacles){
        if(o.type==='movingWall'){
          // Sine oscillation (spec: 64-96px amplitude)
          o.t += dt * 2; // oscillation speed
          o.x = o.x0 + Math.sin(o.t) * o.amp;
        }
        if(o.type==='blinkSpike'){
          // Update blinking animation
          o.blinkPhase += dt * o.blinkFreq;
          o.visible = Math.floor(o.blinkPhase) % 2 === 0; // Blink on/off
        }
        if(o.type==='laser'){
          // Oscillating lasers
          o.moveOffset += dt * o.moveSpeed;
          if(o.vertical){
            o.y = o.y0 + Math.sin(o.moveOffset / 100) * 100 * scale;
          } else {
            o.x = o.x0 + Math.sin(o.moveOffset / 100) * 100 * scale;
          }
        }
        o.x -= shift;
      }

      // Check if reached goal
      const goal = obstacles.find(o => o.type === 'goal');
      if(goal && player.x >= goal.x && !levelComplete){
        levelComplete = true;
        completeLevel();
      }
      
      // Check dash pads for speed boost
      for(const o of obstacles){
        if(o.type === 'dashPad'){
          const inPad = player.x >= o.x && player.x <= o.x + o.w && player.y >= o.y && player.y <= o.y + o.h;
          if(inPad && !o.activated){
            o.activated = true;
            player.vx *= 1.5; // Speed boost
            setTimeout(() => { player.vx /= 1.5; o.activated = false; }, 800);
          }
        }
      }

      // Collisions (exact polygon checks)
      const poly = makeArrowPoly(player.x, player.y, player.angle);
      for(const o of obstacles){
        if(o.type==='tri'){
          // Spike triangles: pointing up from floor or down from ceiling
          const triPts = (o.side==='floor') ?
            [{x:o.x + o.w/2, y:o.y - o.h}, {x:o.x, y:o.y}, {x:o.x + o.w, y:o.y}] :
            [{x:o.x + o.w/2, y:o.y + o.h}, {x:o.x, y:o.y}, {x:o.x + o.w, y:o.y}];
          // Check if any player point is in triangle
          for(const pp of poly){ if(pointInTriangle(pp.x,pp.y, triPts[0],triPts[1],triPts[2])) { die(); break; } }
          // Check if any triangle point is in player bounds
          const pr = {x:Math.min(...poly.map(p=>p.x)), y:Math.min(...poly.map(p=>p.y)), w:Math.max(...poly.map(p=>p.x))-Math.min(...poly.map(p=>p.x)), h:Math.max(...poly.map(p=>p.y))-Math.min(...poly.map(p=>p.y))};
          for(const tp of triPts){ if(tp.x>=pr.x && tp.x<=pr.x+pr.w && tp.y>=pr.y && tp.y<=pr.y+pr.h) { die(); break; } }
        } else if(o.type==='blinkSpike' && o.visible){
          // Blinking spikes only hurt when visible
          const triPts = (o.side==='floor') ?
            [{x:o.x + o.w/2, y:o.y - o.h}, {x:o.x, y:o.y}, {x:o.x + o.w, y:o.y}] :
            [{x:o.x + o.w/2, y:o.y + o.h}, {x:o.x, y:o.y}, {x:o.x + o.w, y:o.y}];
          for(const pp of poly){ if(pointInTriangle(pp.x,pp.y, triPts[0],triPts[1],triPts[2])) { die(); break; } }
          const pr = {x:Math.min(...poly.map(p=>p.x)), y:Math.min(...poly.map(p=>p.y)), w:Math.max(...poly.map(p=>p.x))-Math.min(...poly.map(p=>p.x)), h:Math.max(...poly.map(p=>p.y))-Math.min(...poly.map(p=>p.y))};
          for(const tp of triPts){ if(tp.x>=pr.x && tp.x<=pr.x+pr.w && tp.y>=pr.y && tp.y<=pr.y+pr.h) { die(); break; } }
        } else if(o.type==='rect' || o.type==='slab' || o.type==='movingWall' || o.type==='laser'){
          const r = {x:o.x, y:o.y, w:o.w, h:o.h};
          for(const pp of poly){ if(pp.x>=r.x && pp.x<=r.x+r.w && pp.y>=r.y && pp.y<=r.y+r.h) { die(); break; } }
        }
        if(!player.alive) break;
      }

      // clamp player y into screen
      if(player.y < 6) player.y = 6;
      if(player.y > H-6) player.y = H-6;
    }
    draw();
    requestAnimationFrame(update);
  }

  // Minimal death SFX (Web Audio API)
  let audioCtx;
  function playDeathSound(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(120, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.15);
    gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.15);
  }

  function die(){
    if(!player.alive) return;
    player.alive = false;
    running = false;
    inputActive = false;
    player.freezeTime = 0.08; // freeze 80ms
    playDeathSound();
    // Flash white at 50% opacity
    flashEl.style.transition = 'none';
    flashEl.style.opacity = '0.5';
    flashEl.style.background = '#ffffff';
    setTimeout(()=>{ flashEl.style.transition = 'opacity 120ms ease'; flashEl.style.opacity = '0'; }, 20);
    
    // Show restart button after a short delay
    setTimeout(()=>{ 
      showRestartButton();
    }, 300);
  }
  
  function completeLevel(){
    running = false;
    inputActive = false;
    
    // Flash green
    flashEl.style.transition = 'none';
    flashEl.style.opacity = '0.4';
    flashEl.style.background = '#9ae6b4';
    setTimeout(()=>{ flashEl.style.transition = 'opacity 300ms ease'; flashEl.style.opacity = '0'; }, 20);
    
    // Show completion message
    setTimeout(()=>{
      if(currentLevel < LEVELS){
        // Go to next level
        currentLevel++;
        resetLevel();
        running = true;
        inputActive = true;
      } else {
        // Completed all levels - return to menu
        gameState = 'mainMenu';
        hud.classList.remove('active');
        mainMenu.style.display = 'flex';
        setTimeout(()=>{
          mainMenu.classList.add('active');
          mainMenu.style.opacity = '1';
        }, 20);
      }
    }, 800);
  }

  function resetLevel(){
    player.y = H/2; 
    player.alive = true; 
    player.vx = player.baseVx; // Reset to base speed
    isMovingUp = true; 
    player.angle = -Math.PI/8; 
    trail.length = 0; 
    levelComplete = false; 
    obstacles = makeLevel(currentLevel);
    
    // Reset speed scaling timers
    gameStartTime = 0;
    lastSpeedIncreaseTime = 0;
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    // background (flat dark)
    ctx.fillStyle = '#030306'; ctx.fillRect(0,0,W,H);
    // draw slabs (ceiling/floor)
    for(const o of obstacles){
      if(o.type==='slab'){
        ctx.fillStyle = '#121212'; if(o.which==='floor') ctx.fillStyle = '#0f1724';
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }
    }
    // Draw obstacles
    for(const o of obstacles){
      if(o.type==='tri'){
        const baseW = o.w; const h = o.h;
        
        // Outer glow
        ctx.shadowColor = 'rgba(255,23,68,0.8)';
        ctx.shadowBlur = Math.round(12 * scale);
        
        // Main spike fill
        ctx.fillStyle = o.color || '#FF1744';
        ctx.beginPath();
        if(o.side==='floor'){
          ctx.moveTo(o.x + baseW/2, o.y - h);
          ctx.lineTo(o.x, o.y);
          ctx.lineTo(o.x + baseW, o.y);
        } else {
          ctx.moveTo(o.x + baseW/2, o.y + h);
          ctx.lineTo(o.x, o.y);
          ctx.lineTo(o.x + baseW, o.y);
        }
        ctx.closePath(); 
        ctx.fill();
        
        // Dark outline for depth
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = Math.round(2 * scale);
        ctx.stroke();
      } else if(o.type==='blinkSpike'){
        if(o.visible){
          const baseW = o.w; const h = o.h;
          
          // Pulsing glow effect
          const pulseIntensity = 0.6 + Math.sin(Date.now() / 200) * 0.4;
          ctx.shadowColor = `rgba(255,215,0,${pulseIntensity})`;
          ctx.shadowBlur = Math.round(15 * scale);
          
          ctx.fillStyle = o.color || '#FFD700';
          ctx.beginPath();
          if(o.side==='floor'){
            ctx.moveTo(o.x + baseW/2, o.y - h);
            ctx.lineTo(o.x, o.y);
            ctx.lineTo(o.x + baseW, o.y);
          } else {
            ctx.moveTo(o.x + baseW/2, o.y + h);
            ctx.lineTo(o.x, o.y);
            ctx.lineTo(o.x + baseW, o.y);
          }
          ctx.closePath(); 
          ctx.fill();
          
          // Outline
          ctx.shadowBlur = 0;
          ctx.strokeStyle = 'rgba(0,0,0,0.4)';
          ctx.lineWidth = Math.round(2 * scale);
          ctx.stroke();
        }
      } else if(o.type==='rect'){
        // Block with gradient for volume
        const gradient = ctx.createLinearGradient(o.x, o.y, o.x, o.y + o.h);
        const baseColor = o.color || '#5E35B1';
        gradient.addColorStop(0, baseColor);
        gradient.addColorStop(0.5, baseColor);
        gradient.addColorStop(1, '#3d2470'); // Darker bottom
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = 'rgba(94,53,177,0.6)';
        ctx.shadowBlur = Math.round(8 * scale);
        ctx.fillRect(o.x, o.y, o.w, o.h);
        
        // Top highlight
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(o.x, o.y, o.w, Math.round(4 * scale));
        
        // Dark outline
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = Math.round(2 * scale);
        ctx.strokeRect(o.x, o.y, o.w, o.h);
      } else if(o.type==='movingWall'){
        // Moving wall with animated pulse
        const pulseSize = Math.sin(Date.now() / 300) * 3 * scale;
        
        const gradient = ctx.createLinearGradient(o.x, o.y, o.x + o.w, o.y + o.h);
        gradient.addColorStop(0, '#2979FF');
        gradient.addColorStop(0.5, '#1565C0');
        gradient.addColorStop(1, '#2979FF');
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = 'rgba(41,121,255,0.8)';
        ctx.shadowBlur = Math.round(15 * scale) + pulseSize;
        ctx.fillRect(o.x, o.y, o.w, o.h);
        
        // Inner lines for tech look
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = Math.round(2 * scale);
        for(let i = 1; i < 4; i++){
          ctx.beginPath();
          ctx.moveTo(o.x, o.y + (o.h / 4) * i);
          ctx.lineTo(o.x + o.w, o.y + (o.h / 4) * i);
          ctx.stroke();
        }
      } else if(o.type==='dashPad'){
        // Dash pad with animated stripes
        const stripePulse = Math.sin(Date.now() / 150) * 0.3 + 0.7;
        
        ctx.fillStyle = o.color || '#FFEA00';
        ctx.shadowColor = `rgba(255,234,0,${stripePulse})`;
        ctx.shadowBlur = Math.round(18 * scale);
        ctx.fillRect(o.x, o.y, o.w, o.h);
        
        // Diagonal stripes
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        const stripeWidth = Math.round(8 * scale);
        for(let i = -o.h; i < o.w; i += stripeWidth * 2){
          ctx.beginPath();
          ctx.moveTo(o.x + i, o.y + o.h);
          ctx.lineTo(o.x + i + o.h, o.y);
          ctx.lineTo(o.x + i + o.h + stripeWidth, o.y);
          ctx.lineTo(o.x + i + stripeWidth, o.y + o.h);
          ctx.closePath();
          ctx.fill();
        }
        
        // Draw arrows on dash pad
        ctx.fillStyle = '#000';
        const arrowY = o.y + o.h/2;
        const arrowSize = Math.round(8 * scale);
        for(let i=0; i<3; i++){
          const arrowX = o.x + o.w * (0.2 + i*0.3);
          ctx.beginPath();
          ctx.moveTo(arrowX + arrowSize, arrowY);
          ctx.lineTo(arrowX - arrowSize/2, arrowY - arrowSize/2);
          ctx.lineTo(arrowX - arrowSize/2, arrowY + arrowSize/2);
          ctx.closePath();
          ctx.fill();
        }
      } else if(o.type==='laser'){
        // Pulsing laser beam
        const laserPulse = Math.sin(Date.now() / 100) * 0.4 + 0.6;
        
        ctx.fillStyle = o.color || '#E91E63';
        ctx.shadowColor = `rgba(233,30,99,${laserPulse})`;
        ctx.shadowBlur = Math.round(20 * scale);
        ctx.fillRect(o.x, o.y, o.w, o.h);
        
        // Inner bright core
        ctx.shadowBlur = 0;
        const coreW = o.vertical ? o.w * 0.3 : o.w;
        const coreH = o.vertical ? o.h : o.h * 0.3;
        const coreX = o.vertical ? o.x + o.w * 0.35 : o.x;
        const coreY = o.vertical ? o.y : o.y + o.h * 0.35;
        
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillRect(coreX, coreY, coreW, coreH);
      } else if(o.type==='bouncePad'){
        // Bounce pad with spring effect
        const bouncePhase = Math.abs(Math.sin(Date.now() / 400));
        const squish = 1 - bouncePhase * 0.2;
        
        ctx.save();
        ctx.translate(o.x + o.w/2, o.y + o.h);
        ctx.scale(1, squish);
        
        ctx.fillStyle = o.color || '#FF9800';
        ctx.shadowColor = 'rgba(255,152,0,0.7)';
        ctx.shadowBlur = Math.round(12 * scale);
        ctx.beginPath();
        ctx.arc(0, -o.h, o.w/2, Math.PI, 0);
        ctx.lineTo(o.w/2, 0);
        ctx.lineTo(-o.w/2, 0);
        ctx.closePath();
        ctx.fill();
        
        // Spring coils
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(0,0,0,0.4)';
        ctx.lineWidth = Math.round(3 * scale);
        const coils = 3;
        for(let i = 0; i < coils; i++){
          const y = (-o.h * 0.6) + (i * o.h * 0.3);
          ctx.beginPath();
          ctx.arc(-o.w/4, y, o.w/6, 0, Math.PI);
          ctx.stroke();
        }
        
        ctx.restore();
      } else if(o.type==='goal'){
        // Goal finish line - green gradient
        const gradient = ctx.createLinearGradient(o.x, 0, o.x + o.w, 0);
        gradient.addColorStop(0, 'rgba(154,230,180,0.3)');
        gradient.addColorStop(0.5, 'rgba(154,230,180,0.8)');
        gradient.addColorStop(1, 'rgba(154,230,180,0.3)');
        ctx.fillStyle = gradient;
        ctx.fillRect(o.x, o.y, o.w, o.h);
        
        // Draw checkered pattern
        ctx.fillStyle = '#9ae6b4';
        const checkSize = Math.round(20 * scale);
        for(let y = 0; y < o.h; y += checkSize){
          for(let x = 0; x < o.w; x += checkSize){
            if((Math.floor(x/checkSize) + Math.floor(y/checkSize)) % 2 === 0){
              ctx.fillRect(o.x + x, y, checkSize, checkSize);
            }
          }
        }
      }
    }
    
    // Draw trail
    for(let i = 0; i < trail.length; i++){
      const t = trail[i];
      const opacity = (i / trail.length) * 0.4; // Fade from 0 to 0.4
      const size = (i / trail.length) * scale; // Grow from 0 to scale
      
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.rotate(t.angle);
      
      ctx.shadowColor = `rgba(0,245,255,${opacity * 0.8})`;
      ctx.shadowBlur = Math.round(8 * size);
      ctx.fillStyle = `rgba(0,245,255,${opacity})`;
      
      // Small triangle for trail
      const trailSize = 24 * size;
      const trailHeight = 32 * size;
      ctx.beginPath();
      ctx.moveTo(trailHeight/2, 0);
      ctx.lineTo(-trailHeight/2, -trailSize/2);
      ctx.lineTo(-trailHeight/2, trailSize/2);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
    }
    
    // Draw player arrow (spec: base 48px, height 64px, neon cyan with glow)
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    
    const baseW = Math.round(48 * scale);
    const height = Math.round(64 * scale);
    const halfH = height / 2;
    
    ctx.shadowColor = 'rgba(0,245,255,0.6)';
    ctx.shadowBlur = Math.round(12 * scale);
    ctx.fillStyle = '#00F5FF';
    ctx.beginPath();
    ctx.moveTo(halfH, 0); // tip (right)
    ctx.lineTo(-halfH, -baseW/2); // top-left
    ctx.lineTo(-halfH, baseW/2); // bottom-left
    ctx.closePath();
    ctx.fill();
    
    // Optional outline (2-3px black)
    ctx.lineWidth = Math.max(2, Math.round(2.5 * scale));
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.moveTo(halfH, 0);
    ctx.lineTo(-halfH, -baseW/2);
    ctx.lineTo(-halfH, baseW/2);
    ctx.closePath();
    ctx.stroke();
    
    ctx.restore();

    // HUD: tiny progress bar
    if(running){
      ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(12,12,160,8);
      const progress = Math.min(1, player.x / levelWidth);
      ctx.fillStyle = '#9ae6b4'; ctx.fillRect(12,12, progress * 160, 8);
    }
  }

  // === MENU SYSTEM ===
  const mainMenu = document.getElementById('mainMenu');
  const levelSelect = document.getElementById('levelSelect');
  const pauseMenu = document.getElementById('pauseMenu');
  const hud = document.getElementById('hud');
  const levelDisplay = document.getElementById('levelDisplay');
  const prevLevelBtn = document.getElementById('prevLevel');
  const nextLevelBtn = document.getElementById('nextLevel');
  const startLevelBtn = document.getElementById('startLevel');
  const restartOverlay = document.getElementById('restartOverlay');
  const previewCanvas = document.getElementById('previewCanvas');
  const previewCtx = previewCanvas.getContext('2d');

  let gameState = 'mainMenu'; // 'mainMenu' | 'levelSelect' | 'playing' | 'paused'
  let unlockedLevels = 6; // All levels unlocked for now
  let selectedLevel = 1; // Currently selected level in menu
  
  // Draw level preview
  function drawLevelPreview(levelNum){
    const pw = previewCanvas.width;
    const ph = previewCanvas.height;
    const previewScale = ph / H;
    
    previewCtx.clearRect(0, 0, pw, ph);
    previewCtx.fillStyle = '#030306';
    previewCtx.fillRect(0, 0, pw, ph);
    
    // Create temporary obstacles for this level
    const tempObstacles = [];
    const tempThickness = 40 * previewScale;
    const tempSpikeBase = 32 * previewScale;
    const tempSpikeHeight = 48 * previewScale;
    const tempBigSpikeBase = 64 * previewScale;
    const tempBigSpikeHeight = (ph/2 - tempThickness);
    const tempBlockW = 128 * previewScale;
    const tempBlockH = 32 * previewScale;
    
    // Draw first 600px worth of level obstacles (scaled to preview)
    const previewRange = 1200; // Show first 1200px of level
    const previewLevel = makeLevel(levelNum);
    
    // Draw floor and ceiling
    previewCtx.fillStyle = '#121212';
    previewCtx.fillRect(0, 0, pw, tempThickness);
    previewCtx.fillStyle = '#0f1724';
    previewCtx.fillRect(0, ph - tempThickness, pw, tempThickness);
    
    for(const o of previewLevel){
      if(o.x > previewRange) continue;
      const px = (o.x / previewRange) * pw;
      
      if(o.type === 'tri'){
        const w = (o.w / scale) * previewScale;
        const h = (o.h / scale) * previewScale;
        
        previewCtx.fillStyle = o.color || '#FF1744';
        previewCtx.beginPath();
        if(o.side === 'floor'){
          previewCtx.moveTo(px + w/2, ph - tempThickness - h);
          previewCtx.lineTo(px, ph - tempThickness);
          previewCtx.lineTo(px + w, ph - tempThickness);
        } else {
          previewCtx.moveTo(px + w/2, tempThickness + h);
          previewCtx.lineTo(px, tempThickness);
          previewCtx.lineTo(px + w, tempThickness);
        }
        previewCtx.closePath();
        previewCtx.fill();
      } else if(o.type === 'rect'){
        const w = (o.w / scale) * previewScale;
        const h = (o.h / scale) * previewScale;
        const y = (o.y / scale) * previewScale;
        previewCtx.fillStyle = o.color || '#5E35B1';
        previewCtx.fillRect(px, y, w, h);
      }
    }
    
    // Draw difficulty indicator
    previewCtx.fillStyle = '#00F5FF';
    previewCtx.font = 'bold 16px Montserrat, sans-serif';
    previewCtx.textAlign = 'right';
    const speeds = [300, 340, 380, 430, 510, 560];
    const lengths = [12000, 6500, 7000, 7500, 8000, 9000];
    previewCtx.fillText(`Speed: ${speeds[levelNum-1]} px/s`, pw - 10, 25);
    previewCtx.fillText(`Length: ${lengths[levelNum-1]} px`, pw - 10, 45);
  }
  
  // Update level display and arrow states
  function updateLevelDisplay(){
    levelDisplay.textContent = `LVL ${selectedLevel}`;
    prevLevelBtn.disabled = selectedLevel <= 1;
    nextLevelBtn.disabled = selectedLevel >= unlockedLevels;
    drawLevelPreview(selectedLevel);
  }
  
  // Arrow navigation handlers
  prevLevelBtn.addEventListener('click', ()=>{
    if(selectedLevel > 1){
      selectedLevel--;
      updateLevelDisplay();
    }
  });
  
  nextLevelBtn.addEventListener('click', ()=>{
    if(selectedLevel < unlockedLevels){
      selectedLevel++;
      updateLevelDisplay();
    }
  });
  
  // Start button handler
  startLevelBtn.addEventListener('click', ()=>{
    selectLevel(selectedLevel);
  });
  
  // Show restart button on death
  function showRestartButton(){
    restartOverlay.classList.add('active');
  }
  
  function hideRestartButton(){
    restartOverlay.classList.remove('active');
  }
  
  // Restart button click handler
  document.getElementById('restartDeath').addEventListener('click', ()=>{
    hideRestartButton();
    resetLevel();
    running = true;
    inputActive = true;
  });

  // Main Menu → Level Select
  document.getElementById('startArrow').addEventListener('click', ()=>{
    if(gameState !== 'mainMenu') return;
    gameState = 'levelSelect';
    
    // Reset to level 1
    selectedLevel = 1;
    updateLevelDisplay();
    
    // Animate: arrow expands and slides up
    const arrow = document.getElementById('startArrow');
    arrow.style.transition = 'transform 0.25s ease-out, opacity 0.2s ease';
    arrow.style.transform = 'translate(-50%, -200%) scale(1.3)';
    arrow.style.opacity = '0';
    
    // Fade out main menu
    setTimeout(()=>{
      mainMenu.style.opacity = '0';
      setTimeout(()=>{
        mainMenu.classList.remove('active');
        mainMenu.style.display = 'none';
        
        // Slide in level select
        levelSelect.style.display = 'flex';
        setTimeout(()=>{
          levelSelect.classList.add('active','show');
        }, 20);
      }, 300);
    }, 100);
  });

  // Level Select → Main Menu (back button)
  document.getElementById('backToMain').addEventListener('click', ()=>{
    if(gameState !== 'levelSelect') return;
    gameState = 'mainMenu';
    
    levelSelect.classList.remove('show');
    setTimeout(()=>{
      levelSelect.classList.remove('active');
      levelSelect.style.display = 'none';
      
      // Reset and show main menu
      const arrow = document.getElementById('startArrow');
      arrow.style.transition = 'none';
      arrow.style.transform = 'translate(-50%,-50%) scale(1)';
      arrow.style.opacity = '1';
      mainMenu.style.display = 'flex';
      setTimeout(()=>{
        mainMenu.classList.add('active');
        mainMenu.style.opacity = '1';
      }, 20);
    }, 350);
  });

  // Select level and start game
  function selectLevel(n){
    currentLevel = n;
    gameState = 'playing';
    isMovingUp = true; // reset to moving up
    
    // Fade to black and start game
    levelSelect.style.opacity = '0';
    flashEl.style.background = '#000';
    flashEl.style.transition = 'opacity 0.3s ease';
    flashEl.style.opacity = '1';
    
    setTimeout(()=>{
      levelSelect.classList.remove('active','show');
      levelSelect.style.display = 'none';
      
      // Start game
      resetLevel();
      running = true;
      inputActive = true;
      hud.classList.add('active');
      
      // Fade in
      setTimeout(()=>{
        flashEl.style.opacity = '0';
        flashEl.style.background = '#fff';
      }, 50);
    }, 300);
  }

  // Pause handling
  document.getElementById('pauseIcon').addEventListener('click', ()=>{
    if(gameState === 'playing') pauseGame();
  });

  window.addEventListener('keydown', e=>{
    if(e.key === 'Escape' && gameState === 'playing') pauseGame();
  });

  function pauseGame(){
    if(!running) return;
    gameState = 'paused';
    running = false;
    isHolding = false;
    inputActive = false;
    pauseMenu.style.display = 'flex';
    setTimeout(()=> pauseMenu.classList.add('active'), 20);
  }

  document.getElementById('resumeBtn').addEventListener('click', ()=>{
    if(gameState !== 'paused') return;
    gameState = 'playing';
    running = true;
    inputActive = true;
    isHolding = false;
    pauseMenu.style.opacity = '0';
    setTimeout(()=>{
      pauseMenu.classList.remove('active');
      pauseMenu.style.display = 'none';
      pauseMenu.style.opacity = '1';
    }, 200);
  });

  document.getElementById('restartBtn').addEventListener('click', ()=>{
    if(gameState !== 'paused') return;
    pauseMenu.style.opacity = '0';
    setTimeout(()=>{
      pauseMenu.classList.remove('active');
      pauseMenu.style.display = 'none';
      pauseMenu.style.opacity = '1';
      gameState = 'playing';
      inputActive = true;
      isHolding = false;
      resetLevel();
      running = true;
    }, 200);
  });

  document.getElementById('exitBtn').addEventListener('click', ()=>{
    if(gameState !== 'paused') return;
    pauseMenu.style.opacity = '0';
    setTimeout(()=>{
      pauseMenu.classList.remove('active');
      pauseMenu.style.display = 'none';
      pauseMenu.style.opacity = '1';
      hud.classList.remove('active');
      
      // Return to main menu
      gameState = 'mainMenu';
      running = false;
      inputActive = false;
      isHolding = false;
      const arrow = document.getElementById('startArrow');
      arrow.style.transition = 'none';
      arrow.style.transform = 'translate(-50%,-50%) scale(1)';
      arrow.style.opacity = '1';
      mainMenu.style.display = 'flex';
      setTimeout(()=>{
        mainMenu.classList.add('active');
        mainMenu.style.opacity = '1';
      }, 20);
    }, 200);
  });

  // start the loop
  requestAnimationFrame(update);
})();
