<!DOCTYPE html>
<html>
<head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <title>Space Shooter — JavaSnake.com</title>
        <meta name="description" content="Space Shooter — fast-paced HTML5 arcade shooter. Pilot your ship, dodge enemy fire and blast aliens.">
        <meta property="og:site_name" content="JavaSnake.com">
        <meta property="og:title" content="Space Shooter — JavaSnake.com">
        <meta property="og:description" content="Arcade space shooter with asteroids and alien waves. Play in your browser.">
        <meta property="og:type" content="game">
        <meta property="og:url" content="https://javasnake.com/space-shooter/shaungame.html">
        <meta property="og:image" content="https://javasnake.com/games-HTML5/preview.png">
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Space Shooter — JavaSnake.com">
        <meta name="twitter:description" content="Arcade space shooter with asteroids and alien waves. Play in your browser.">
        <meta name="twitter:image" content="https://javasnake.com/games-HTML5/preview.png">
        <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "Game",
            "name": "Space Shooter",
            "description": "Arcade space shooter with asteroids and alien waves.",
            "url": "https://javasnake.com/space-shooter/shaungame.html"
        }
        </script>
        <style>
        * { margin: 0; padding: 0; }
        body { 
            margin: 0; 
            background: #223; 
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas { 
            display: block;
            background: #223;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
        window.onload = function() {
            const canvas = document.getElementById("game");
            const ctx = canvas.getContext("2d");

            // Game constants
            const ENEMY_FIRE_RATE = 2000;
            const STRONG_ENEMY_FIRE_RATE = 1500;
            const XP_PER_ORB = 20;
            const ENEMY_SPEED = 2.5;
            const ENEMY_FOLLOW_SPEED = 2;
            const GRENADE_COOLDOWN = 1500;
            const GRENADE_SPEED = 12;
            const GRENADE_BLAST_RADIUS = 150;
            const GRENADE_MAX_DISTANCE = 300;
            const GRENADE_RECHARGE_TIME = 7000;
            const BULLET_SPEED = 16;
            const ENEMY_BULLET_SPEED = 12;
            const MISSILE_SPEED = 10;
            const MISSILE_DAMAGE = 50;
            const MISSILE_COOLDOWN = 20000; // 20 seconds
            const MISSILE_TURN_SPEED = 0.15;

            // Sound effects setup
            const sounds = {
                shoot: new Audio('data:audio/wav;base64,UklGRhwEAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YfgDAAB/f39/f39/f39/f39/f3+AgP+Af3+Af4B/gICAgICAgH9/gICAgICAgH9/f39/f4CBgICAgICBgYGBgoGBgoKDg4SDhISFhoeIiYmKi4uMjY2Oj4+QkZGSk5OTlJWUlZWWlpaXlpaWlZWVlJOSkpGPjo2Mi4qJiIeGhYSEg4KBgYB/f319fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRUU1JSUVBPT09OTU1MTEtLSklJSEdHRkZFRUVERENDQ0NCQkJCQkFBQUFAQEBAQD8/Pz8/Pz8+Pj4+PT09PT08PDw8PDw7Ozs7Ozs7Ozs7Ozs7PDw8PDw8PT09PT4+Pj4/Pz8/QEBAQEFBQUFCQkJCQ0NDQ0RERERFRUVFRkZGRkdHR0dISEhISUlJSUpKSkpLS0tLTExMTE1NTU1OTk5OT09PT1BQUFBRUVFRUlJSUlNTU1NUVFRUVVVVVVZWVlZXV1dXWFhYWFlZWVlaWlpaW1tbW1xcXFxdXV1dXl5eXl9fX19gYGBgYWFhYWJiYmJjY2NjZGRkZGVlZWVmZmZmZ2dnZ2hoaGhpaWlpa2tra2xsbGxtbW1tbm5ubm9vb29wcHBwcXFxcXJycnJzc3NzdHR0dHV1dXV2dnZ2d3d3d3h4eHh5eXl5enp6ent7e3t8fHx8fX19fX5+fn5/f39/gICAgIGBgYGCgoKCg4ODg4SEhISFhYWFhoaGhoeHh4eIiIiIiYmJiYqKioqLi4uLjIyMjI2NjY2Ojo6Oj4+Pj5CQkJCRkZGRkpKSkpOTk5OUlJSUlZWVlZaWlpaXl5eXmJiYmJmZmZmampqam5ubm5ycnJydnZ2dnp6enp+fn5+goKCgoaGhoaKioqKjo6OjpKSkpKWlpaWmpqamn5+fnJeXlJCQjIiIhYGBfnt7d3NzbmppZWFhXVlZVVFRTktLR0REREZISk1PUlVXWl1fYmRnaGlqamlpaGZlY2JgX11cW1pZWVhYV1dXV1dXV1hYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29wcHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJx8fHyAgICAgICBgYGBgoKCgoODg4OEhISEhYWFhYaGhoaHh4eHiIiIiImJiYmKioqKi4uLi4yMjIyNjY2Njg=='),
                explosion: new Audio('data:audio/wav;base64,UklGRuQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YcADAACAgICAgICAgICAgICAgICAgICAgICBgoKDg4SEhYWFhoaHiImKi4yNjo+QkJGRkZGRkZKSkpKTk5OTk5STk5STlJOUk5OTkpKRkZCQj4+OjYyLioqJiIeGhYSEg4KBgIB/f398fHt6eXh3d3Z1dHNycXBwb25tbWxramloZ2ZlZGNiYWBfX15dXFtbWllYV1ZVVFNTUlFQUE9OTU1MS0tKSUlIR0dGRUVERENCQkFBQEA/Pz4+PT08PDw7Ozs6Ojo5OTk5ODg4ODg4ODg4ODg4ODg4ODk5OTk5Ojo6Ozs7PDw8PT0+Pj8/QEBBQUJCQ0NEREVFRkZHR0hISUlKSkpLS0xMTU1NTk5OT09PUFBQUVFRU1JTU1RUVFVVVVZWVldXV1hYWFlZWVpaWltbW1xcXF1dXV5eXl9fX2BgYGFhYWJiYmNjY2RkZGVlZWZmZmdnZ2hoaGlpaWpqamtra2xsbG1tbW5ubm9vb3BwcHFxcXJycnNzc3R0dHV1dXZ2dnd3d3h4eHl5eXp6ent7e3x8fH19fX5+fn9/f4CAgIGBgYKCgoODg4SEhIWFhYaGhoeHh4iIiImJiYqKiouLi4yMjI2NjY6Ojo+Pj5CQkJGRkZKSkpOTk5SUlJWVlZaWlpeXl5iYmJmZmZqampubm5ycnJ2dnZ6enp+fn6CgoKGhoaKioqOjo6SkpKWlpaampqWhoZ6bm5eUlJCNjYmGhoKAgHx5eXVycm5ra2hlZWFfX1taWVhXV1ZWVldXV1hYWFlaWltbXFxdXV5eX19gYGFhYmJjY2RkZWVmZmdnaGhpaWpqa2tsbG1tbm5vb3BwcXFycnNzdHR1dXZ2d3d4eHl5enp7e3x8fX1+fn9/gICBgYKCg4OEhISFhYaGh4eIiImJioqLi4yMjY2Ojo+PkJCRkZKSk5OUlJWVlpaXl5iYmZmampubp6eno6OjoJ6em5mZlpSUkZCPjYyLiomIh4aFhIOCgYCAgH9/f39+fn5+fn5+fn5/f39/f4CAgICBgYGBgoKCgoODg4OEhISEhYWFhYaGhoaHh4eHiIiIiA=='),
                collect: new Audio('data:audio/wav;base64,UklGRpQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXADAAAAAAAAgICAgICAgICBgYGBgoKCgoODg4OEhISEhYWFhYaGhoaHh4eHiIiIiImJiYmKioqKi4uLi4yMjIyNjY2Njo6Oj4+Pj5CQkJCRkZGRkpKSkpOTk5OUlJSUlZWVlZaWlpaXl5eXmJiYmJmZmZmampqam5ubm5ycnJydnZ2dnp6enp+fn5+goKCgoaGhoaKioqKjo6Ojo6Ojo6SkpKSkpKSkpKSkpKSko6Ojo6Ojo6OioqKioaGhoaCgoKCfn5+fnp6enZ2dnZ2dnJycnJubm5uampqamZmZmZiYmJiXl5eXlpaWlpWVlZWUlJSUk5OTk5KSkpKRkZGRkJCQkI+Pj4+Ojo6OjY2NjYyMjIyLi4uLioqKiomJiYmIiIiIh4eHh4aGhoaFhYWFhISEhIODg4OCgoKCgYGBgYCAgIB/f39/fn5+fn19fX18fHx8e3t7e3p6enp5eXl5eHh4eHd3d3d2dnZ2dXV1dXR0dHRzc3NzcnJycnFxcXFwcHBwb29vb25ubm5tbW1tbGxsbGtra2tqampqaWlpaWhoaGhnZ2dnZmZmZmVlZWVkZGRkY2NjY2JiYmJhYWFhYGBgYF9fX19eXl5eXV1dXVxcXFxbW1tbWlpaWllZWVlYWFhYV1dXV1ZWVlZVVVVVVFRUVFNTU1NSUlJSUVFRUVBQUFBPT09PTk5OTk1NTU1MTExMTU1NTU1NTU1OTk5OTk5OT09PT09PT1BQUFBQUFBRUVFRUVFRUlJSUlJSUlNTU1NTU1NUVFRUVFRUVVVVVVVVVVZWVlZWVlZXV1dXV1dXWFhYWFhYWFlZWVlZWVlaWlpaWlpaW1tbW1tbW1xcXFxcXFxdXV1dXV1dXl5eXl5eXl9fX19fX19gYGBgYGBgYWFhYWFhYWJiYmJiYmJjY2NjY2NjZGRkZGRkZGVlZWVlZWVmZmZmZmZmZ2dnZ2dnZ2hoaGhoaGhpaWlpaWlpampqampqamtra2tra2tsbGxsbGxsbW1tbW1tbW5ubm5ubm5vb29vb29vcHBwcHBwcHFxcXFxcXFycnJycnJyc3Nzc3Nzc3R0dHR0dHR1dXV1dXV1dnZ2dnZ2dnd3d3d3d3d4eHh4eHh4eXl5eXl5eXp6enp6enp7e3t7e3t7fHx8fHx8fH19fX19fX1+fn5+fn5+f39/f39/f4CAgICAgICBgYGBgYGBgoKCgoKCgoODg4ODg4OEhISEhISEhYWFhYWFhYaGhoaGhoaHh4eHh4eHiIiIiIiIiImJiYmJiYmKioqKioqKi4uLi4uLi4yMjIyMjIw='),
                hit: new Audio('data:audio/wav;base64,UklGRpIDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YW4DAACBgoKDhISFhoaHiImJiouLjI2Njo+PkJGRkpOTlJWVlpeXmJmZmpubm5ydnZ6enp+fn6CgoKGhoaKioqOjo6SkpKWlpaWlpaWlpKSko6OjoqKioaCgoJ+fn56enp2dnZycnJubm5qampmZmZiYmJeXl5aWlpWVlZSUlJOTk5KSkpGRkZCQkI+Pj46Ojo2NjYyMjIuLi4qKiomJiYiIiIeHh4aGhoWFhYSEhIODg4KCgoGBgYCAgH9/f35+fn19fXx8fHt7e3p6enl5eXh4eHd3d3Z2dnV1dXR0dHNzc3JycnFxcXBwcG9vb25ubm1tbWxsbGtra2tqamppaWloaGhnZ2dmZmZlZWVkZGRjY2NiYmJhYWFgYGBfX19eXl5dXV1cXFxbW1taWlpZWVlYWFhXV1dWVlZVVVVUVFRTU1NSUlJRUVFQUFBPT09OTk5NTU1MTExLS0tKSkpJSUlISEhHR0dGRkZFRUVEREREREREREVFRUVGRkZGR0dHR0hISEhJSUlJSkpKSktLS0tMTExMTU1NTU5OTk5PT09PUFBQUFFRUVFSUlJSU1NTU1RUVFRVVVVVVlZWVldXV1dYWFhYWVlZWVpaWlpbW1tbXFxcXF1dXV1eXl5eX19fX2BgYGBhYWFhYmJiYmNjY2NkZGRkZWVlZWZmZmZnZ2dnbGxsa2trampqaWlpaGhoZ2dnZmZmZWVlZGRkY2NjYmJiYWFhYGBgX19fXl5eXV1dXFxcW1tbWlpaWVlZWFhYV1dXVlZWVVVVVFRUU1NTUlJSUVFRUFBQT09PTk5OTU1NTExMS0tLSkpKSUlJSEhIR0dHRkZGRUVFREREQ0NDQkJCQUFBQEBAPz8/Pj4+PT09PDw8Ozs7Ojo6OTk5ODg4Nzc3NjY2NTU1NDQ0MzMzMjIyMTExMDAwLy8vLi4uLS0tLCwsKysrKioqKSkpKCgoJycnJiYmJSUlJCQkIyMjIiIiISEhICAgHx8fHh4eHR0dHBwcGxsbGhoaGRkZGBgYFxcXFhYWFRUVFBQUExMTEhISEREREBAQDw8PDg4ODQ0NDAwMDAwMDQ0NDg4ODw8PEBAQEREREhISExMTFBQUFRUVFhYWFxcXGBgYGRkZGhoaGxsbHBwcHR0dHh4eHx8fICAgISEhIiIiIyMjJCQkJSUlJiYmJycnKCgoKSkpKioqKysrLCwsLS0tLi4uLy8vMDAwMTExMjIyMzMzNDQ0NTU1NjY2Nzc3ODg4OTk5Ojo6Ozs7PDw8PT09Pj4+Pz8/QEBAQUFBQkJCQ0NDREREQkFBQEA/Pz49PTw8Ozs6Ojk5ODg3NzY2NTU0NDMzMjIxMTAwLy8uLi0tLCwrKyoqKSkoKCcnJiYlJSQkIyMiIiEhIB8fHh4dHRwcGxsaGhkZGBgXFxYWFRUUFBMTEhIRERAQDw8ODg0NDAwLCwoKCQkICAgHBwcGBgYFBQUEBAQDAwMCAgIBAQEAAAA=')};
            // Set volume for all sounds
            Object.values(sounds).forEach(sound => sound.volume = 0.3);

            // Expose a simple audio control API for site-wide mute (used by index.html)
            (function(){
                // remember default volumes
                const defaultVolumes = {};
                Object.keys(sounds).forEach(k => defaultVolumes[k] = sounds[k].volume);

                window.gameAudio = {
                    _defaultVolumes: defaultVolumes,
                    // mute or restore volumes
                    setMuted: function(muted){
                        if(muted){
                            Object.values(sounds).forEach(s => { s._prevVolume = s.volume; s.volume = 0; });
                        } else {
                            Object.keys(sounds).forEach(k => {
                                const s = sounds[k];
                                s.volume = (s._prevVolume !== undefined) ? s._prevVolume : (defaultVolumes[k] || 0.3);
                                delete s._prevVolume;
                            });
                        }
                    },
                    // convenience getter
                    get muted(){ return Object.values(sounds).every(s => s.volume === 0); }
                };

                // Listen for site-wide mute messages from parent/originating pages
                window.addEventListener('message', function(ev){
                    try {
                        const d = ev.data;
                        if(d && d.type === 'site_mute'){
                            window.gameAudio.setMuted(!!d.muted);
                        }
                    } catch(e) {
                        // ignore malformed messages
                    }
                }, false);
            })();

            // Ensure canvas is properly sized
            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener("resize", resize);
            resize();

            // Player setup
            const player = {
                x: canvas.width / 2,
                y: canvas.height - 80,
                radius: 20,
                speed: 7,
                health: 10,
                maxHealth: 10,
                level: 1,
                xp: 0,
                xpToNext: 100,
                baseFireRate: 200,
                lastShot: 0,
                lastGrenade: 0,
                lastHeal: 0,
                grenades: 3,
                maxGrenades: 3,
                grenadeRechargeTime: 0,
                lastMissile: 0,
                lockedEnemy: null
            };

            const missiles = [];

            // Game arrays
            const bullets = [];
            const enemyBullets = [];
            const enemies = [];
            const grenades = [];
            const xpOrbs = [];
            const explosions = [];

            // Controls
            const keys = {
                w: false, s: false, a: false, d: false
            };
            const mouse = { x: 0, y: 0, down: false };

            function updateMouse(e) {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
            }

            // Event listeners
            window.addEventListener("keydown", (e) => {
                if (e.key.toLowerCase() === 'q') {
                    const now = performance.now();
                    if (now - player.lastMissile >= MISSILE_COOLDOWN && enemies.length > 0) {
                        // Lock onto random enemy
                        const randomIndex = Math.floor(Math.random() * enemies.length);
                        player.lockedEnemy = enemies[randomIndex];
                    }
                }
                if (e.key.toLowerCase() in keys) {
                    keys[e.key.toLowerCase()] = true;
                }
                if (e.code === "Space") {
                    mouse.down = true;
                }
                if (e.key.toLowerCase() === "g" && player.grenades > 0) {
                    const now = performance.now();
                    if (now - player.lastGrenade >= GRENADE_COOLDOWN) {
                        player.grenades--;
                        if (player.grenades === player.maxGrenades - 1) {
                            player.grenadeRechargeTime = now;
                        }
                        const dx = mouse.x - player.x;
                        const dy = mouse.y - player.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const ndx = dx / length;
                        const ndy = dy / length;
                        
                        grenades.push({
                            x: player.x + ndx * player.radius,
                            y: player.y + ndy * player.radius,
                            vx: ndx * GRENADE_SPEED,
                            vy: ndy * GRENADE_SPEED,
                            spawnTime: now,
                            startX: player.x,
                            startY: player.y,
                            radius: 8
                        });
                        player.lastGrenade = now;
                    }
                }
            });

            window.addEventListener("keyup", (e) => {
                if (e.key.toLowerCase() in keys) {
                    keys[e.key.toLowerCase()] = false;
                }
                if (e.code === "Space") {
                    mouse.down = false;
                }
            });

            canvas.addEventListener("mousemove", updateMouse);
            canvas.addEventListener("mousedown", (e) => {
                updateMouse(e);
                mouse.down = true;
                if (player.lockedEnemy && performance.now() - player.lastMissile >= MISSILE_COOLDOWN) {
                    const angle = Math.atan2(player.lockedEnemy.y - player.y, player.lockedEnemy.x - player.x);
                    missiles.push({
                        x: player.x,
                        y: player.y,
                        angle: angle,
                        target: player.lockedEnemy
                    });
                    player.lastMissile = performance.now();
                    player.lockedEnemy = null;
                    sounds.shoot.currentTime = 0;
                    sounds.shoot.play();
                }
            });
            canvas.addEventListener("mouseup", () => mouse.down = false);

            function getPlayerFireRate() {
                return Math.max(50, player.baseFireRate - (player.level - 1) * 50);
            }

            function createExplosion(x, y) {
                explosions.push({
                    x, y,
                    startTime: performance.now(),
                    radius: GRENADE_BLAST_RADIUS,
                    duration: 500
                });
            }

            function spawnXPOrbs(x, y) {
                for(let i = 0; i < 3; i++) {
                    const angle = (Math.PI * 2 / 3) * i;
                    const distance = 20;
                    xpOrbs.push({
                        x: x + Math.cos(angle) * distance,
                        y: y + Math.sin(angle) * distance,
                        startX: x + Math.cos(angle) * distance,
                        startY: y + Math.sin(angle) * distance,
                        radius: 5,
                        pulseOffset: Math.random() * Math.PI * 2,
                        speed: 2 + Math.random() * 1.5
                    });
                }
            }

            function spawnEnemy() {
                const isStrong = player.level >= 5 && Math.random() < 0.3;
                const side = Math.floor(Math.random() * 3);
                let x, y;
                
                switch(side) {
                    case 0:
                        x = Math.random() * canvas.width;
                        y = 0;
                        break;
                    case 1:
                        x = canvas.width;
                        y = Math.random() * canvas.height;
                        break;
                    case 2:
                        x = 0;
                        y = Math.random() * canvas.height;
                        break;
                }
                
                enemies.push({
                    x, y,
                    radius: isStrong ? 25 : 20,
                    health: isStrong ? 5 : 2,
                    isStrong: isStrong,
                    lastShot: 0
                });
            }

            function playerShoot() {
                const now = performance.now();
                if (now - player.lastShot < getPlayerFireRate()) return;

                // Calculate direction vector
                const dx = mouse.x - player.x;
                const dy = mouse.y - player.y;
                // Normalize the vector
                const length = Math.sqrt(dx * dx + dy * dy);
                const dirX = dx / length;
                const dirY = dy / length;
                
                sounds.shoot.currentTime = 0;
                sounds.shoot.play();
                bullets.push({
                    x: player.x + dirX * player.radius,
                    y: player.y + dirY * player.radius,
                    vx: dirX * BULLET_SPEED,
                    vy: dirY * BULLET_SPEED,
                    radius: 5
                });
                player.lastShot = now;
            }            function enemyShoot(enemy) {
                const fireRate = enemy.isStrong ? STRONG_ENEMY_FIRE_RATE : ENEMY_FIRE_RATE;
                if (!enemy.lastShot || performance.now() - enemy.lastShot >= fireRate) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const ndx = dx / length;
                    const ndy = dy / length;
                    
                    enemyBullets.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: ndx * ENEMY_BULLET_SPEED,
                        vy: ndy * ENEMY_BULLET_SPEED,
                        radius: 4
                    });
                    enemy.lastShot = performance.now();
                }
            }

            function addXP(amount) {
                player.xp += amount;
                while (player.xp >= player.xpToNext) {
                    player.xp -= player.xpToNext;
                    player.level++;
                    player.xpToNext = Math.floor(player.xpToNext * 1.2);
                }
            }

            function update() {
                const now = performance.now();
                
                // Grenade recharge
                if (player.grenades < player.maxGrenades && now - player.grenadeRechargeTime >= GRENADE_RECHARGE_TIME) {
                    player.grenades++;
                    player.grenadeRechargeTime = now;
                }
                
                // Health regeneration
                if (now - player.lastHeal >= 1000) {
                    if (player.health < player.maxHealth) {
                        player.health = Math.min(player.maxHealth, player.health + 0.2);
                    }
                    player.lastHeal = now;
                }

                // Move player
                if (keys.a) player.x -= player.speed;
                if (keys.d) player.x += player.speed;
                if (keys.w) player.y -= player.speed;
                if (keys.s) player.y += player.speed;

                // Keep player in bounds
                player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
                player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

                // Player shooting
                if (mouse.down) {
                    playerShoot();
                }

                // Update XP orbs
                for (let i = xpOrbs.length - 1; i >= 0; i--) {
                    const orb = xpOrbs[i];
                    const distToPlayer = Math.hypot(player.x - orb.x, player.y - orb.y);
                    
                    if (distToPlayer < player.radius + orb.radius) {
                        addXP(XP_PER_ORB);
                        sounds.collect.currentTime = 0;
                        sounds.collect.play();
                        xpOrbs.splice(i, 1);
                        continue;
                    }

                    // Move towards player if within range
                    const ATTRACTION_RANGE = 300;
                    const MAX_DISTANCE_FROM_SPAWN = 250;
                    
                    if (distToPlayer < ATTRACTION_RANGE) {
                        const dx = player.x - orb.x;
                        const dy = player.y - orb.y;
                        const distToSpawn = Math.hypot(orb.x - orb.startX, orb.y - orb.startY);
                        
                        if (distToSpawn < MAX_DISTANCE_FROM_SPAWN) {
                            const angle = Math.atan2(dy, dx);
                            // Move faster when further from player
                            const speedMultiplier = Math.min(2, distToPlayer / 100);
                            orb.x += Math.cos(angle) * orb.speed * speedMultiplier;
                            orb.y += Math.sin(angle) * orb.speed * speedMultiplier;
                        }
                    }
                }

                // Update grenades
                for (let i = grenades.length - 1; i >= 0; i--) {
                    const grenade = grenades[i];
                    grenade.x += grenade.vx;
                    grenade.y += grenade.vy;
                    
                    const distanceTraveled = Math.hypot(grenade.x - grenade.startX, grenade.y - grenade.startY);
                    if (distanceTraveled >= GRENADE_MAX_DISTANCE) {
                        grenade.vx = 0;
                        grenade.vy = 0;
                    }

                    if (performance.now() - grenade.spawnTime >= 1500) {
                        createExplosion(grenade.x, grenade.y);
                        sounds.explosion.currentTime = 0;
                        sounds.explosion.play();
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const enemy = enemies[j];
                            const dx = enemy.x - grenade.x;
                            const dy = enemy.y - grenade.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist <= GRENADE_BLAST_RADIUS) {
                                enemy.health -= Math.ceil(3 * (1 - dist / GRENADE_BLAST_RADIUS));
                                if (enemy.health <= 0) {
                                    spawnXPOrbs(enemy.x, enemy.y);
                                    enemies.splice(j, 1);
                                }
                            }
                        }
                        grenades.splice(i, 1);
                        continue;
                    }
                    
                    if (grenade.x < 0 || grenade.x > canvas.width || grenade.y < 0 || grenade.y > canvas.height) {
                        grenades.splice(i, 1);
                    }
                }

                // Update missiles
                for (let i = missiles.length - 1; i >= 0; i--) {
                    const missile = missiles[i];
                    if (!missile.target.health || missile.target.health <= 0) {
                        missiles.splice(i, 1);
                        continue;
                    }

                    // Calculate angle to target
                    const targetAngle = Math.atan2(missile.target.y - missile.y, missile.target.x - missile.x);
                    // Gradually rotate towards target
                    const angleDiff = targetAngle - missile.angle;
                    missile.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), MISSILE_TURN_SPEED);

                    // Move missile
                    missile.x += Math.cos(missile.angle) * MISSILE_SPEED;
                    missile.y += Math.sin(missile.angle) * MISSILE_SPEED;

                    // Check for hit
                    const dx = missile.x - missile.target.x;
                    const dy = missile.y - missile.target.y;
                    if (Math.sqrt(dx * dx + dy * dy) < missile.target.radius) {
                        missile.target.health -= MISSILE_DAMAGE;
                        createExplosion(missile.x, missile.y);
                        sounds.explosion.currentTime = 0;
                        sounds.explosion.play();
                        if (missile.target.health <= 0) {
                            spawnXPOrbs(missile.target.x, missile.target.y);
                            const index = enemies.indexOf(missile.target);
                            if (index > -1) {
                                enemies.splice(index, 1);
                            }
                        }
                        missiles.splice(i, 1);
                    }
                }

                // Update explosions
                for (let i = explosions.length - 1; i >= 0; i--) {
                    const explosion = explosions[i];
                    const age = now - explosion.startTime;
                    if (age >= explosion.duration) {
                        explosions.splice(i, 1);
                    }
                }

                // Update player bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;

                    if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                        bullets.splice(i, 1);
                        continue;
                    }

                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const dx = bullet.x - enemy.x;
                        const dy = bullet.y - enemy.y;
                        if (Math.sqrt(dx * dx + dy * dy) < bullet.radius + enemy.radius) {
                            enemy.health--;
                            bullets.splice(i, 1);
                            if (enemy.health <= 0) {
                                spawnXPOrbs(enemy.x, enemy.y);
                                enemies.splice(j, 1);
                            }
                            break;
                        }
                    }
                }

                // Update enemy bullets
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = enemyBullets[i];
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;

                    if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                        enemyBullets.splice(i, 1);
                        continue;
                    }

                    const dx = bullet.x - player.x;
                    const dy = bullet.y - player.y;
                    if (Math.sqrt(dx * dx + dy * dy) < bullet.radius + player.radius) {
                        player.health--;
                        sounds.hit.currentTime = 0;
                        sounds.hit.play();
                        enemyBullets.splice(i, 1);
                        if (player.health <= 0) {
                            player.health = player.maxHealth;
                            player.xp = 0;
                            player.level = 1;
                            enemies.length = 0;
                            enemyBullets.length = 0;
                            xpOrbs.length = 0;
                        }
                    }
                }

                // Update enemies
                for (const enemy of enemies) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 200) {
                        enemy.x += (dx / dist) * ENEMY_FOLLOW_SPEED;
                        enemy.y += (dy / dist) * ENEMY_FOLLOW_SPEED;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        enemy.x += Math.cos(angle + Math.PI/2) * ENEMY_FOLLOW_SPEED;
                        enemy.y += Math.sin(angle + Math.PI/2) * ENEMY_FOLLOW_SPEED;
                    }
                    
                    enemyShoot(enemy);
                }

                // Spawn new enemies
                if (Math.random() < 0.012) {
                    spawnEnemy();
                }

                draw();
                requestAnimationFrame(update);
            }

            function draw() {
                ctx.fillStyle = "#223";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw explosions
                for (const explosion of explosions) {
                    const progress = (performance.now() - explosion.startTime) / explosion.duration;
                    const size = explosion.radius * (1 - progress);
                    const alpha = 1 - progress;

                    // Draw explosion rays
                    const rays = 12;
                    for(let i = 0; i < rays; i++) {
                        const angle = (Math.PI * 2 / rays) * i + progress * Math.PI;
                        ctx.save();
                        ctx.translate(explosion.x, explosion.y);
                        
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                        gradient.addColorStop(0, `rgba(255, 200, 50, ${alpha})`);
                        gradient.addColorStop(0.2, `rgba(255, 100, 50, ${alpha * 0.5})`);
                        gradient.addColorStop(1, "rgba(255, 50, 50, 0)");
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, size, angle, angle + Math.PI/6);
                        ctx.lineTo(0, 0);
                        ctx.fill();
                        ctx.restore();
                    }

                    // Draw shockwave
                    ctx.strokeStyle = `rgba(255, 200, 50, ${alpha * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, size * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw XP orbs with pulsing effect
                ctx.save();
                for (const orb of xpOrbs) {
                    const pulseSize = 1 + Math.sin(performance.now() / 500 + orb.pulseOffset) * 0.2;
                    
                    // Outer glow
                    const gradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.radius * 3 * pulseSize);
                    gradient.addColorStop(0, "rgba(0,170,255,0.3)");
                    gradient.addColorStop(1, "rgba(0,170,255,0)");
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(orb.x, orb.y, orb.radius * 3 * pulseSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Core
                    ctx.fillStyle = "#0af";
                    ctx.beginPath();
                    ctx.arc(orb.x, orb.y, orb.radius * pulseSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Shine effect
                    const shine = ctx.createLinearGradient(
                        orb.x - orb.radius, orb.y - orb.radius,
                        orb.x + orb.radius, orb.y + orb.radius
                    );
                    shine.addColorStop(0, "rgba(255,255,255,0.5)");
                    shine.addColorStop(0.5, "rgba(255,255,255,0)");
                    ctx.fillStyle = shine;
                    ctx.beginPath();
                    ctx.arc(orb.x, orb.y, orb.radius * pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();

                // Draw player
                const playerAngle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(playerAngle);
                
                ctx.fillStyle = "#0af";
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(-15, 15);
                ctx.lineTo(-10, 0);
                ctx.lineTo(-15, -15);
                ctx.closePath();
                ctx.fill();

                if (keys.w || keys.a || keys.s || keys.d) {
                    ctx.fillStyle = "rgba(255,100,0,0.5)";
                    ctx.beginPath();
                    ctx.moveTo(-15, 8);
                    ctx.lineTo(-25, 0);
                    ctx.lineTo(-15, -8);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();

                // Draw player bullets
                ctx.fillStyle = "#fff";
                for (const bullet of bullets) {
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw enemy bullets
                ctx.fillStyle = "#f55";
                for (const bullet of enemyBullets) {
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw missiles and lock-on
                for (const missile of missiles) {
                    ctx.save();
                    ctx.translate(missile.x, missile.y);
                    ctx.rotate(missile.angle);

                    // Draw missile body
                    ctx.fillStyle = '#f55';
                    ctx.beginPath();
                    ctx.moveTo(15, 0);
                    ctx.lineTo(-10, 5);
                    ctx.lineTo(-5, 0);
                    ctx.lineTo(-10, -5);
                    ctx.closePath();
                    ctx.fill();

                    // Draw missile trail
                    ctx.strokeStyle = '#f55';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(-20, 0);
                    ctx.stroke();

                    ctx.restore();
                }

                // Draw lock-on indicator
                if (player.lockedEnemy) {
                    ctx.strokeStyle = '#f00';
                    ctx.lineWidth = 2;
                    const time = performance.now() / 200;
                    const size = 30 + Math.sin(time) * 5;
                    
                    // Draw rotating brackets
                    ctx.save();
                    ctx.translate(player.lockedEnemy.x, player.lockedEnemy.y);
                    ctx.rotate(time);
                    
                    // Draw brackets
                    ctx.beginPath();
                    // Top-left bracket
                    ctx.moveTo(-size, -size/2);
                    ctx.lineTo(-size, -size);
                    ctx.lineTo(-size/2, -size);
                    // Top-right bracket
                    ctx.moveTo(size, -size/2);
                    ctx.lineTo(size, -size);
                    ctx.lineTo(size/2, -size);
                    // Bottom-left bracket
                    ctx.moveTo(-size, size/2);
                    ctx.lineTo(-size, size);
                    ctx.lineTo(-size/2, size);
                    // Bottom-right bracket
                    ctx.moveTo(size, size/2);
                    ctx.lineTo(size, size);
                    ctx.lineTo(size/2, size);
                    ctx.stroke();
                    
                    ctx.restore();
                }

                // Draw grenades
                for (const grenade of grenades) {
                    ctx.save();
                    ctx.translate(grenade.x, grenade.y);
                    ctx.rotate(performance.now() / 200);

                    // Main body
                    ctx.fillStyle = "#444";
                    ctx.beginPath();
                    ctx.arc(0, 0, grenade.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Highlight
                    ctx.fillStyle = "#666";
                    ctx.beginPath();
                    ctx.arc(-grenade.radius/3, -grenade.radius/3, grenade.radius/2, 0, Math.PI * 2);
                    ctx.fill();

                    // Pin and handle
                    ctx.strokeStyle = "#ff0";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, -grenade.radius, 3, 0, Math.PI * 2);
                    ctx.moveTo(0, -grenade.radius);
                    ctx.lineTo(0, -grenade.radius * 1.5);
                    ctx.stroke();

                    ctx.restore();

                    if (performance.now() - grenade.spawnTime >= 1000) {
                        const alpha = (Math.sin(performance.now() / 100) + 1) / 2;
                        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(grenade.x, grenade.y, GRENADE_BLAST_RADIUS, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Draw enemies
                for (const enemy of enemies) {
                    const enemyAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    ctx.rotate(enemyAngle);

                    ctx.fillStyle = enemy.isStrong ? "#f22" : "#f55";
                    ctx.beginPath();
                    ctx.moveTo(20, 0);
                    ctx.lineTo(-15, 15);
                    ctx.lineTo(-10, 0);
                    ctx.lineTo(-15, -15);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = "rgba(255,100,50,0.5)";
                    ctx.beginPath();
                    ctx.moveTo(-15, 8);
                    ctx.lineTo(-25, 0);
                    ctx.lineTo(-15, -8);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();

                    const barWidth = enemy.radius * 2;
                    const barHeight = 4;
                    ctx.fillStyle = "#333";
                    ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.radius - 10, barWidth, barHeight);
                    ctx.fillStyle = "#f55";
                    ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.radius - 10, (enemy.health/(enemy.isStrong ? 5 : 2)) * barWidth, barHeight);
                }

                // Draw HUD
                const barWidth = 200;
                const barHeight = 15;
                const barX = 20;
                const barY = 20;

                ctx.fillStyle = "#333";
                ctx.fillRect(barX, barY, barWidth, barHeight);
                ctx.fillStyle = player.health > 3 ? "#5f5" : "#f55";
                ctx.fillRect(barX, barY, (player.health/player.maxHealth) * barWidth, barHeight);

                const xpBarY = barY + barHeight + 10;
                ctx.fillStyle = "#333";
                ctx.fillRect(barX, xpBarY, barWidth, barHeight);
                ctx.fillStyle = "#0af";
                ctx.fillRect(barX, xpBarY, (player.xp/player.xpToNext) * barWidth, barHeight);

                ctx.fillStyle = "#fff";
                ctx.font = "14px Arial";
                ctx.fillText(`Level ${player.level}`, barX, xpBarY + barHeight + 25);
                ctx.fillText(`Fire Rate: ${(1000/getPlayerFireRate()).toFixed(1)} shots/sec`, barX, xpBarY + barHeight + 45);

                // Draw grenade count
                const grenadeX = canvas.width - 100;
                const grenadeY = 30;
                ctx.fillStyle = "#444";
                for(let i = 0; i < player.maxGrenades; i++) {
                    ctx.beginPath();
                    ctx.arc(grenadeX + i * 25, grenadeY, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = "#ff0";
                for(let i = 0; i < player.grenades; i++) {
                    ctx.beginPath();
                    ctx.arc(grenadeX + i * 25, grenadeY, 8, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (player.grenades < player.maxGrenades) {
                    const rechargeProgress = Math.min(1, (performance.now() - player.grenadeRechargeTime) / GRENADE_RECHARGE_TIME);
                    ctx.fillStyle = `rgba(255, 255, 0, 0.3)`;
                    ctx.beginPath();
                    ctx.arc(grenadeX + player.grenades * 25, grenadeY, 8, -Math.PI/2, -Math.PI/2 + rechargeProgress * Math.PI * 2);
                    ctx.lineTo(grenadeX + player.grenades * 25, grenadeY);
                    ctx.fill();
                }
            }

            // Start the game
            update();
        };
    </script>
</body>
</html>
